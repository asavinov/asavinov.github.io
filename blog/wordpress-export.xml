<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.5.2" created="2017-10-07 18:40" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Concept-oriented blog</title>
	<link>http://conceptoriented.org/blogs</link>
	<description>Next generation programming and data modeling paradigms</description>
	<pubDate>Sat, 07 Oct 2017 18:40:16 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://conceptoriented.org/blogs</wp:base_site_url>
	<wp:base_blog_url>http://conceptoriented.org/blogs</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[savinov]]></wp:author_login><wp:author_email><![CDATA[savinov@conceptoriented.org]]></wp:author_email><wp:author_display_name><![CDATA[savinov]]></wp:author_display_name><wp:author_first_name><![CDATA[Alexandr]]></wp:author_first_name><wp:author_last_name><![CDATA[Savinov]]></wp:author_last_name></wp:author>

	<wp:category><wp:term_id>2</wp:term_id><wp:category_nicename><![CDATA[cob]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[Concept-Oriented Blog]]></wp:cat_name><wp:category_description><![CDATA[Concept-oriented blog]]></wp:category_description></wp:category>
	<wp:category><wp:term_id>5</wp:term_id><wp:category_nicename><![CDATA[cop]]></wp:category_nicename><wp:category_parent><![CDATA[cob]]></wp:category_parent><wp:cat_name><![CDATA[cop]]></wp:cat_name><wp:category_description><![CDATA[concept-oriented programming]]></wp:category_description></wp:category>
	<wp:category><wp:term_id>1</wp:term_id><wp:category_nicename><![CDATA[uncategorized]]></wp:category_nicename><wp:category_parent><![CDATA[]]></wp:category_parent><wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>3</wp:term_id><wp:category_nicename><![CDATA[main]]></wp:category_nicename><wp:category_parent><![CDATA[cob]]></wp:category_parent><wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name></wp:category>
	<wp:category><wp:term_id>6</wp:term_id><wp:category_nicename><![CDATA[codeproject]]></wp:category_nicename><wp:category_parent><![CDATA[cob]]></wp:category_parent><wp:cat_name><![CDATA[CodeProject]]></wp:cat_name><wp:category_description><![CDATA[CodeProject]]></wp:category_description></wp:category>
	<wp:category><wp:term_id>4</wp:term_id><wp:category_nicename><![CDATA[com]]></wp:category_nicename><wp:category_parent><![CDATA[cob]]></wp:category_parent><wp:cat_name><![CDATA[com]]></wp:cat_name><wp:category_description><![CDATA[concept-oriented model]]></wp:category_description></wp:category>
	<wp:tag><wp:term_id>20</wp:term_id><wp:tag_slug><![CDATA[active-references]]></wp:tag_slug><wp:tag_name><![CDATA[active references]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>29</wp:term_id><wp:tag_slug><![CDATA[bubbling]]></wp:tag_slug><wp:tag_name><![CDATA[bubbling]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>28</wp:term_id><wp:tag_slug><![CDATA[capturing]]></wp:tag_slug><wp:tag_name><![CDATA[capturing]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>7</wp:term_id><wp:tag_slug><![CDATA[concept]]></wp:tag_slug><wp:tag_name><![CDATA[concept]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>8</wp:term_id><wp:tag_slug><![CDATA[concept-oriented-model]]></wp:tag_slug><wp:tag_name><![CDATA[concept-oriented model]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>12</wp:term_id><wp:tag_slug><![CDATA[concept-oriented-programming]]></wp:tag_slug><wp:tag_name><![CDATA[concept-oriented programming]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>34</wp:term_id><wp:tag_slug><![CDATA[cop]]></wp:tag_slug><wp:tag_name><![CDATA[cop]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>10</wp:term_id><wp:tag_slug><![CDATA[domain-modeling]]></wp:tag_slug><wp:tag_name><![CDATA[domain modeling]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>18</wp:term_id><wp:tag_slug><![CDATA[domain-specific-references]]></wp:tag_slug><wp:tag_name><![CDATA[domain-specific references]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>30</wp:term_id><wp:tag_slug><![CDATA[dual-methods]]></wp:tag_slug><wp:tag_name><![CDATA[dual methods]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>26</wp:term_id><wp:tag_slug><![CDATA[event-handling]]></wp:tag_slug><wp:tag_name><![CDATA[event handling]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>25</wp:term_id><wp:tag_slug><![CDATA[hierarchical-address-space]]></wp:tag_slug><wp:tag_name><![CDATA[hierarchical address space]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>24</wp:term_id><wp:tag_slug><![CDATA[inclusion-relation]]></wp:tag_slug><wp:tag_name><![CDATA[inclusion relation]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>31</wp:term_id><wp:tag_slug><![CDATA[incoming-methods]]></wp:tag_slug><wp:tag_name><![CDATA[incoming methods]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>27</wp:term_id><wp:tag_slug><![CDATA[javascript]]></wp:tag_slug><wp:tag_name><![CDATA[javascript]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>14</wp:term_id><wp:tag_slug><![CDATA[object]]></wp:tag_slug><wp:tag_name><![CDATA[object]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>16</wp:term_id><wp:tag_slug><![CDATA[object-access]]></wp:tag_slug><wp:tag_name><![CDATA[object access]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>17</wp:term_id><wp:tag_slug><![CDATA[object-representation]]></wp:tag_slug><wp:tag_name><![CDATA[object representation]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>22</wp:term_id><wp:tag_slug><![CDATA[objects]]></wp:tag_slug><wp:tag_name><![CDATA[objects]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>32</wp:term_id><wp:tag_slug><![CDATA[outgoing-methods]]></wp:tag_slug><wp:tag_name><![CDATA[outgoing methods]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>15</wp:term_id><wp:tag_slug><![CDATA[programming-paradigms]]></wp:tag_slug><wp:tag_name><![CDATA[programming paradigms]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>13</wp:term_id><wp:tag_slug><![CDATA[reference]]></wp:tag_slug><wp:tag_name><![CDATA[reference]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>19</wp:term_id><wp:tag_slug><![CDATA[reference-modeling]]></wp:tag_slug><wp:tag_name><![CDATA[reference modeling]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>23</wp:term_id><wp:tag_slug><![CDATA[references]]></wp:tag_slug><wp:tag_name><![CDATA[references]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>11</wp:term_id><wp:tag_slug><![CDATA[relation-modeling]]></wp:tag_slug><wp:tag_name><![CDATA[relation modeling]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>33</wp:term_id><wp:tag_slug><![CDATA[reverse-overriding]]></wp:tag_slug><wp:tag_name><![CDATA[reverse overriding]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>9</wp:term_id><wp:tag_slug><![CDATA[unified-model]]></wp:tag_slug><wp:tag_name><![CDATA[unified model]]></wp:tag_name></wp:tag>
	<wp:tag><wp:term_id>21</wp:term_id><wp:tag_slug><![CDATA[values]]></wp:tag_slug><wp:tag_name><![CDATA[values]]></wp:tag_name></wp:tag>
	<wp:term><wp:term_id><![CDATA[20]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[active-references]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[active references]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[29]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[bubbling]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[bubbling]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[28]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[capturing]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[capturing]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[7]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[concept]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[concept]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[2]]></wp:term_id><wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy><wp:term_slug><![CDATA[cob]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[Concept-Oriented Blog]]></wp:term_name><wp:term_description><![CDATA[Concept-oriented blog]]></wp:term_description></wp:term>
	<wp:term><wp:term_id><![CDATA[8]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[concept-oriented-model]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[concept-oriented model]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[12]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[concept-oriented-programming]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[concept-oriented programming]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[5]]></wp:term_id><wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy><wp:term_slug><![CDATA[cop]]></wp:term_slug><wp:term_parent><![CDATA[cob]]></wp:term_parent><wp:term_name><![CDATA[cop]]></wp:term_name><wp:term_description><![CDATA[concept-oriented programming]]></wp:term_description></wp:term>
	<wp:term><wp:term_id><![CDATA[34]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[cop]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[cop]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[10]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[domain-modeling]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[domain modeling]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[18]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[domain-specific-references]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[domain-specific references]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[30]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[dual-methods]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[dual methods]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[26]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[event-handling]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[event handling]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[25]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[hierarchical-address-space]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[hierarchical address space]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[24]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[inclusion-relation]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[inclusion relation]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[31]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[incoming-methods]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[incoming methods]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[27]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[javascript]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[javascript]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[14]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[object]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[object]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[16]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[object-access]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[object access]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[17]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[object-representation]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[object representation]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[22]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[objects]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[objects]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[32]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[outgoing-methods]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[outgoing methods]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[15]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[programming-paradigms]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[programming paradigms]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[13]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[reference]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[reference]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[19]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[reference-modeling]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[reference modeling]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[23]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[references]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[references]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[11]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[relation-modeling]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[relation modeling]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[33]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[reverse-overriding]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[reverse overriding]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[1]]></wp:term_id><wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy><wp:term_slug><![CDATA[uncategorized]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[Uncategorized]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[3]]></wp:term_id><wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy><wp:term_slug><![CDATA[main]]></wp:term_slug><wp:term_parent><![CDATA[cob]]></wp:term_parent><wp:term_name><![CDATA[Uncategorized]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[9]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[unified-model]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[unified model]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[21]]></wp:term_id><wp:term_taxonomy><![CDATA[post_tag]]></wp:term_taxonomy><wp:term_slug><![CDATA[values]]></wp:term_slug><wp:term_parent><![CDATA[]]></wp:term_parent><wp:term_name><![CDATA[values]]></wp:term_name></wp:term>
	<wp:term><wp:term_id><![CDATA[6]]></wp:term_id><wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy><wp:term_slug><![CDATA[codeproject]]></wp:term_slug><wp:term_parent><![CDATA[cob]]></wp:term_parent><wp:term_name><![CDATA[CodeProject]]></wp:term_name><wp:term_description><![CDATA[CodeProject]]></wp:term_description></wp:term>
	<wp:term><wp:term_id><![CDATA[4]]></wp:term_id><wp:term_taxonomy><![CDATA[category]]></wp:term_taxonomy><wp:term_slug><![CDATA[com]]></wp:term_slug><wp:term_parent><![CDATA[cob]]></wp:term_parent><wp:term_name><![CDATA[com]]></wp:term_name><wp:term_description><![CDATA[concept-oriented model]]></wp:term_description></wp:term>

	<generator>https://wordpress.org/?v=4.5.2</generator>

	<item>
		<title>Sample Page</title>
		<link>http://conceptoriented.org/blogs/?page_id=2</link>
		<pubDate>Sat, 13 Sep 2014 15:12:36 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false">http://conceptoriented.org/blogs/?page_id=2</guid>
		<description></description>
		<content:encoded><![CDATA[This is an example page. It's different from a blog post because it will stay in one place and will show up in your site navigation (in most themes). Most people start with an About page that introduces them to potential site visitors. It might say something like this:
<blockquote>Hi there! I'm a bike messenger by day, aspiring actor by night, and this is my blog. I live in Los Angeles, have a great dog named Jack, and I like pi√±a coladas. (And gettin' caught in the rain.)</blockquote>
...or something like this:
<blockquote>The XYZ Doohickey Company was founded in 1971, and has been providing quality doohickeys to the public ever since. Located in Gotham City, XYZ employs over 2,000 people and does all kinds of awesome things for the Gotham community.</blockquote>
As a new WordPress user, you should go to <a href="http://conceptoriented.org/blogs/wp-admin/">your dashboard</a> to delete this page and create new pages for your content. Have fun!]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2</wp:post_id>
		<wp:post_date><![CDATA[2014-09-13 15:12:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2014-09-13 15:12:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sample-page]]></wp:post_name>
		<wp:status><![CDATA[private]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[page]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>The Concept-Oriented Portal</title>
		<link>http://conceptoriented.org/blogs/?p=4</link>
		<pubDate>Sat, 29 Nov 2008 13:44:25 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Today I started my own web site <a href="http://conceptoriented.org/" target="_blank">http://conceptoriented.org/</a> for collecting all information about the concept-oriented approach to programming, database model, analysis and design. Currently it includes only very limited information on the concept-oriented data model (COM) but I will try to update this site regularly. The next thing is to add more information on the general concept-oriented principles and COM faq.]]></content:encoded>
		<excerpt:encoded><![CDATA[Today I started my own web site http://conceptoriented.org/ for collecting all information about the concept-oriented approach to programming, database model, analysis and design. Currently it includes only very limited information on the concept-oriente&hellip;]]></excerpt:encoded>
		<wp:post_id>4</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:44:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:44:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[the-concept-oriented-portal]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>FAQ on the concept-oriented principles (philosophy)</title>
		<link>http://conceptoriented.org/blogs/?p=5</link>
		<pubDate>Sat, 29 Nov 2008 13:46:27 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Today I added the first FAQ to my concept-oriented <a href="http://conceptoriented.org/">portal</a>.

The concept-oriented paradigm is based on a set of general principles. In particular, these principles describe what objects are, where do they live, how they are represented and accessed. Although these principle are of very general and even somewhat philosophical character they are quite important for understanding the basics of more concrete mechanisms such as concept-oriented programming (COP), concept-oriented database model (CODBM) and concept-oriented design. In particular, these principles are useful in understanding differences from the existing paradigms such as the object-oriented one.

The next FAQ will be on the concept-oriented data model (COM).]]></content:encoded>
		<excerpt:encoded><![CDATA[Today I added the first FAQ to my concept-oriented portal. The concept-oriented paradigm is based on a set of general principles. In particular, these principles describe what objects are, where do they live, how they are represented and accessed. Al&hellip;]]></excerpt:encoded>
		<wp:post_id>5</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:46:27]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:46:27]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[faq-on-the-concept-oriented-principles-philosophy]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>FAQ on the concept-oriented data model (COM) has been added</title>
		<link>http://conceptoriented.org/blogs/?p=6</link>
		<pubDate>Sat, 29 Nov 2008 13:48:00 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[I have just added new FAQ into my <a href="http://conceptoriented.org/">conceptoriented.org</a> portal. This new COM FAQ answers such questions as what is the concept-oriented data model (COM) syntax and semantics, what are concepts and items, dimensions and realationships, grouping and aggregation. It also covers some implementation issues and provides a comparison with other database models and data modeling approaches.]]></content:encoded>
		<excerpt:encoded><![CDATA[I have just added new FAQ into my conceptoriented.org portal. This new CoM FAQ answers such questions as what is the concept-oriented data model (CoM) syntax and semantics, what are concepts and items, dimensions and realationships, grouping and aggregat&hellip;]]></excerpt:encoded>
		<wp:post_id>6</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:48:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:48:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[faq-on-the-concept-oriented-data-model-cop-has-been-added]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="com"><![CDATA[com]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>FAQ on the Concept-Oriented Query Language (COQL) has been added</title>
		<link>http://conceptoriented.org/blogs/?p=7</link>
		<pubDate>Sat, 29 Nov 2008 13:49:29 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[I have just added new FAQ into my <a href="http://conceptoriented.org/">conceptoriented.org</a> portal, which answers simple questions concerning the Concept-Oriented Query Language (COQL). COQL is one possible query language suitable for the use in the concept-oriented data model.

I also started a thread in <a href="http://www.dbforums.com/">http://www.dbforums.com/</a> where this model can be discussed. Here is the link: <a href="http://www.dbforums.com/t1072076.html">http://www.dbforums.com/t1072076.html</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[I have just added new FAQ into my conceptoriented.org portal, which answers simple questions concerning the Concept-Oriented Query Language (CoQL). CoQL is one possible query language suitable for the use in the concept-oriented data model. I also st&hellip;]]></excerpt:encoded>
		<wp:post_id>7</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:49:29]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:49:29]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[faq-on-the-concept-oriented-query-language-coql-has-been-added]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="com"><![CDATA[com]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Concept-oriented programming: 2nd iteration</title>
		<link>http://conceptoriented.org/blogs/?p=10</link>
		<pubDate>Sat, 29 Nov 2008 13:39:02 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[The first version of COP I described this summer was rather general and provided only main principles with generic exemples and use cases. Since then I have collected much more material and made significant advances so it makes sense to make the second iteration in order to fix the state of the process. So I started to write new larger and deeper paper where I am going to describe in details general principles of concept-oriented programming, specify new version of ConceptJ, and provide more examples, use cases and design patterns. Although some important features are still absent the paradigm and the language are much more expressive now (but still extremely simple) and can already be applied to develop real world systems. I hope I will be able to finish it in reasonable time...]]></content:encoded>
		<excerpt:encoded><![CDATA[The first version of COP I described this summer was rather general and provided only main principles with generic exemples and use cases. Since then I have collected much more material and made significant advances so it makes sense to make the second i&hellip;]]></excerpt:encoded>
		<wp:post_id>10</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:39:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:39:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[concept-oriented-programming-2nd-iteration]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>What is an object?</title>
		<link>http://conceptoriented.org/blogs/?p=11</link>
		<pubDate>Sat, 29 Nov 2008 13:50:28 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Here are some fundamental characteristics of objects:
<ul>
 	<li>Each object has a concrete position in space, which is constant and cannot be changed. Having a position or coordinate means also object existence. Objects are created with some position and then die in the same position.</li>
 	<li>Objects exhibit (represent) themselves in other contexts (parts of the spaces) indirectly via references (which are not objects because do have concrete position in space). Thus we never know what an object is in reality because the only thing we have is a reference.</li>
 	<li>In addition to existence objects have their semantics, which is defined as a combination of other objects, which are normally represented by reference. Thus semantically an object is simply a combination of other objects.</li>
 	<li>Objects are indivisible things just because they have a concrete position in space. We cannot separate their semantic constituents. The only thing that can be separated is object reference. Moreover, the fact that several objects have one and the same coordinate makes them a new object. In other words, an ability of parts to be placed in one point underlies the mechanism of object construction.</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[Here are some fundamental characteristics of objects:Each object has a concrete position in space, which is constant and cannot be changed. Having a position or coordinate means also object existence. Objects are created with some position and then d&hellip;]]></excerpt:encoded>
		<wp:post_id>11</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:50:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:50:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[what-is-an-object]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>What is a reference?</title>
		<link>http://conceptoriented.org/blogs/?p=12</link>
		<pubDate>Sat, 29 Nov 2008 13:51:18 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Here are some fundamental characteristics of references:
<ul>
 	<li>Reference does not have a concrete position in space and hence does not have its own reference, i.e., references represent themselves by value</li>
 	<li>Reference exists within objects as their parts (fields) where it has a concrete position, which is not a reference (it is an offset). In other words, objects are identified by references within a container while references are identified by positins within an object.</li>
 	<li>References are passed by value and can exist in different objects so that references are travelling things (in contrast to objects which have a constant position in space).</li>
 	<li>References may have an internal structure (just like objects)</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[Here are some fundamental characteristics of references:Reference does not have a concrete position in space and hence does not have its own reference, i.e., references represent themselves by valueReference exists within objects as their parts (fi&hellip;]]></excerpt:encoded>
		<wp:post_id>12</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:51:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:51:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[what-is-a-reference]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Concept-Oriented Programming</title>
		<link>http://conceptoriented.org/blogs/?p=13</link>
		<pubDate>Sat, 29 Nov 2008 13:53:55 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Concept-oriented programming (COP) is a next generation programming paradigm. It is based on using concepts as the main programming construct. A concept is a pair of two classes: an object class and a reference class. Instances of the object class, objects, are passed by reference. Instances of the reference class, references, are passed by value and are intended to indirectly represent objects. Each concept has a parent concept, called superconcept, specified via inclusion relation. A concept has also a pair of special continuation methods (for both the object class and the reference class), which are used to organize a reference resolution and object access.

A concept-oriented program uses concepts instead of classes (a concept with the empty reference class is equivalent to the conventional class as defined in OOP). The idea of COP is that superconcepts provide a level of indirection for their subconcepts. They play a role of environment or container. In particular, they provide a custom format of references and custom access procedures. In COP we never know what is the object reference format and where does it reside. Such a simple method invocation as <tt>myObject.myMethod()</tt> my trigger rather complex intermediate functions, which are executed behind the scenes. The object itself may reside anywhere in the world - it depends on its superconcepts. For example, we might develop concepts for managing a huge number of tiny objects, for persistent objects, for remote objects etc. The idea is that this hidden level of RA functionality has to be an integral part of the program because it account for a great deal and even most of its complexity.

COP complements the concept-oriented data model (COP) and is being developed as a part of the concept-oriented paradigm. More information on COP and other related new technologies can be found on the concept-oriented portal: <a href="http://conceptoriented.org">http://conceptoriented.org</a>. In particular, it has an article describing in details what is a concept and how it is used in COP. Questions and opinions can be written in a new concept-oriented forum: <a href="http://conceptoriented.org/forums/index.php">http://conceptoriented.org/forums/index.php</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[Concept-oriented programming (CoP) is a next generation programming paradigm. It is based on using concepts as the main programming construct. A concept is a pair of two classes: an object class and a reference class. Instances of the object class, objec&hellip;]]></excerpt:encoded>
		<wp:post_id>13</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:53:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:53:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>FAQ on the concept-oriented programming (COP) updated</title>
		<link>http://conceptoriented.org/blogs/?p=14</link>
		<pubDate>Sat, 29 Nov 2008 13:55:50 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[I have added two new sections to <a href="http://conceptoriented.org/faqs/cop-faq.html">COP FAQ</a>.
The first added section on object creation and deletion answers questions concerning object life-cycle management. The second added section provides examples of Hello World programs which demonstrate various principles of the concept-oriented programming.

More information on these and other concept-oriented
technologies can be found on the <a href="http://conceptoriented.org/">
concept-oriented portal</a>. In particular, questions on these next generation technologies can be asked on the recently opened
<a href="http://conceptoriented.org/forums/index.php">forum</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[I have added two new sections to CoP FAQ. The first added section on object creation and deletion answers questions concerning object life-cycle management. The second added section provides examples of Hello World programs which demonstrate various pr&hellip;]]></excerpt:encoded>
		<wp:post_id>14</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:55:50]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:55:50]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[faq-on-the-concept-oriented-programming-cop-updated]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Three steps to understand the main idea of the concept-oriented programming (COP)</title>
		<link>http://conceptoriented.org/blogs/?p=15</link>
		<pubDate>Sat, 29 Nov 2008 13:58:03 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<b>Step 1</b>

Let us assume that there is a reference to an account object and we want to get the account balance:
<pre>Account account = customer.getAccount(); 
double balance = account.getBalance();</pre>
In OOP variable account would contain a reference in some system default format. In COP it may contain <i>any</i> data that <i>indirectly</i> represents the account object.

<b>Step 2</b>

In order to describe the format of references the programmer can use classes. Thus the program consists of two kinds of classes: object classes and reference classes. Instances of the object classes are passed-by-reference only while instances of the reference classes are passed-by-value and represent objects. If we want our account and other classes of objects to be represented by some custom indirect references then we need to define the corresponding reference class:
<pre><b>reference</b> Persistent {
  int primaryKey; 
}</pre>
It includes one integer field which is this object primary key in some database. In order to automatically resolve this reference the reference class needs a so called <i>continuation method</i>.
<pre><b>reference</b> Persistent { 
  int primaryKey; 
  void <b>continue</b>() { 
    Object o = resolve(primaryKey); 
    o.<b>continue</b>(); 
    unresolve(o); 
  } 
}</pre>
Notice that this reference class is unaware of any object class it will represent. So it can be used to represent any class of objects including Account and Customer.

<b>Step 3</b>

Now we have some target classes we want to represent indirectly such as Account and Customer and a reference class which is able to indirectly represent other objects. In order to specify how objects of various classes have to be represented we use a so called <i>inclusion relation</i> (which generalizes inheritance).
<pre>class Account <b>in</b> Persistent { 
  double balance = 0; 
  double getBalance() { return balance; } 
}</pre>
From this definition the compiler can easily learn that this object class has to be represented by references in the format of the reference class Persistent. Notice that this object class does not include any information on its identity and other details of the representation and access mechanism. Hence we can easily change the way it is represented by including in some other reference class. In any case the following statements
<pre>Account account = customer.getAccount(); 
double balance = account.getBalance();</pre>
are executed transparently, i.e., we do not need to know how an object is being represented in order to use it. All the peculiarities of the object representation and access are hidden in the reference class and these intermediate functions are executed seamlessly behind the scenes. In particular, if the account objects will reside on Mars while the customer objects somewhere else in the Universe the code of the program will not change ? it is enough only to change the declarations. That is one of the main goals of the concept-oriented programming. One important consequence is that a great deal of the program complexity is concentrated in the reference classes and these functions are never called because they are executed automatically as other objects are being accessed.

More information on this approach to programming can be found here: <a href="http://conceptoriented.org">http://conceptoriented.org</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[Step 1  Let us assume that there is a reference to an account object and we want to get the account balance:Account account = customer.getAccount(); double balance = account.getBalance();  In OOP variable account would contain a reference in so&hellip;]]></excerpt:encoded>
		<wp:post_id>15</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:58:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:58:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[three-steps-to-understand-the-main-idea-of-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Creating concept instances</title>
		<link>http://conceptoriented.org/blogs/?p=16</link>
		<pubDate>Sat, 29 Nov 2008 13:59:37 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[A <i>concept</i> in the concept-oriented programming (COP) is a pair of two classes: an <i>object class</i> and a <i>reference class</i>. For example, concept Account could be defined as follows:
<pre><b>concept</b> Account 
  <b>reference</b> {
    String accountNumber; 
    ... // Other fields and methods 
  }
  <b>class</b> {
    double balance; 
    ... // Other fields and methods 
  }</pre>
All members in this concept are broken into two groups: the members of the reference class and the members of the object class.

Concepts are used as classes when declaring variables, parameters or fields:
<pre>Account myAccount;</pre>
However, in contrast to OOP, each instance of a concept produces two instances: an instance of the reference class, called reference, and an instance of the object class, called object. The idea here is that the new reference is stored directly in the variable while the new object is created in some storage. Thus references and objects live in two worlds: references are stored and passed by value while objects are stored and passed by reference only.

If we create a new account
<pre>Account myAccount = new Account();</pre>
then variable myAccount will contain an account number, which is a field of the reference class. The account itself is created in some storage, e.g., in memory or in a database. Thus the account can be accessed only by means of information stored in its reference. For example, let us assume that we need to get the account balance:
<pre>myAccount.getBalance();</pre>
Notice however that this variable contains an account number rather than a direct (native) reference. So how the account object can be accessed? A short answer is that this reference has to be resolved and only after the native reference is restored the object can be accessed.

An advantage of such a division onto a reference class and an object class is that we can effectively separate two concerns:
<ul>
 	<li>object business methods (OBM) and</li>
 	<li>object representation and access (ORA).</li>
</ul>
Any object is represented and accessed <i>indirectly</i> using its custom references which are defined in a reference class of some concept. Yet the object represented by is reference is accessed <i>transparently</i> just like in OOP. For example, we can serialize this account reference and after loading it back again the reference is still valid because it is actually the account number rather than a native reference. The programmer can use objects as usual by calling its methods while all the intermediate functionality will be executed automatically behind the scenes.

More information on this approach to programming can be found here: <a href="http://conceptoriented.org">http://conceptoriented.org</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[A concept in the concept-oriented programming (COP) is a pair of two classes: an object class and a reference class. For example, concept Account could be defined as follows: concept Account   reference {    String accountNumber;     ... // Other&hellip;]]></excerpt:encoded>
		<wp:post_id>16</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 13:59:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 13:59:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[creating-concept-instances]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>New paper on concept-oriented programming</title>
		<link>http://conceptoriented.org/blogs/?p=17</link>
		<pubDate>Sat, 29 Nov 2008 14:00:51 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<b>An Approach to Programming Based on Concepts</b>

Abstract

In this paper we describe a new approach to programming which generalizes object-oriented programming. It is based on using a new programming construct, called concept, which generalizes classes. Concept is defined as a pair of two classes: one reference class and one object class. Each concept has a parent concept which is specified using inclusion relation generalizing inheritance. We describe several important mechanisms such as reference resolution, context stack, dual methods and life-cycle management, inheritance and polymorphism. This approach to programming is positioned as a new programming paradigm and therefore we formulate its main principles and rules.

Table of contents:
1 Introduction 2
2 Representation and Access 3
2.1 Entities and Identities 3
2.2 Inclusion Relation 5
2.3 Substitution Relation 7
3 Concepts for Describing Entities and Identities 8
3.1 Reference Class and Object Class 8
3.2 Concept Definition 9
3.3 Meta-Transition 12
4 Concept Inclusion 14
4.1 Complex References 14
4.2 Sequence of Access 16
4.3 Context Stack 20
4.4 Life-Cycle Management 22
5 Operations with References 25
5.1 Reference Structure and Parameters 25
5.2 Left and Right Casting 27
5.3 Reference Length Control 28
6 CoP as a Generalization of OOP 30
6.1 Inheritance 30
6.2 Polymorphism 32
6.3 Object Construction and Deletion 34
7 Principles of the Concept-Oriented Paradigm 35
7.1 There is Always Something in-between 35
7.2 There is Always Something out There 36
7.3 Everything Has an Identity and Entity 37
7.4 Everything is Relative and Virtual 39
8 Related Work 39
8.1 Hardware Level 39
8.2 Software Level 40
8.3 Design Patterns 41
8.4 Language Level 42
8.5 Conceptual Approaches 45
8.6 Concept Related Approaches 46
9 Conclusions 47
10 References 47

This and other papers can be downloaded from <a href="http://conceptoriented.org"> http://conceptoriented.org</a> (section Publications) or directly <a href="http://conceptoriented.org/savinov/publicat/imi-report_07_2.pdf">here</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[An Approach to Programming Based on ConceptsAbstractIn this paper we describe a new approach to programming which generalizes object-oriented programming. It is based on using a new programming construct, called concept, which generalizes classes&hellip;]]></excerpt:encoded>
		<wp:post_id>17</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:00:51]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:00:51]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[new-paper-on-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Concept-oriented programming (COP) and smart pointers in C++</title>
		<link>http://conceptoriented.org/blogs/?p=18</link>
		<pubDate>Sat, 29 Nov 2008 14:04:03 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<b>1. Modelling references in COP </b>

In the <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP) concepts are used instead of classes. A <a href="http://conceptoriented.org/wiki/Concept_(concept-oriented_programming)">concept</a> is a pair consisting of one reference class and one object class. Instances of the reference class are passed-by-value and are intended to represent instances of the object class. Thus objects and references always exist in pairs reflecting two sides of one and the same thing (identity and entity). For example, to describe bank accounts we could define concept Account:
<pre><b>concept</b> Account 
    <b>reference</b> { 
        String accNo; 
        ... 
    } 
    <b>object</b> { 
        double balance; 
        ... 
    }</pre>
Now, if we define a variable of this concept, it will contain an instance of this concept reference class (account number). In contrast, in OOP it would contain a direct primitive reference to an object in memory.

References can be viewed as intermediate elements or proxies. They intercept any access to the object. For example, if we apply some method to a variable, say, account.getBalance(), then it will be executed in the reference and only after that its execution can be continued in the object. Thus COP and concepts allow the programmer to effectively model custom references which provide a level of indirection but simulate normal references.

<b>2. Modelling references by smart pointers </b>

The same result could be reached using an old C++ pattern called <a href="http://en.wikipedia.org/wiki/Smart_pointer">smart pointers</a>. The main goal of this technique consists in describing custom references by normal classes so that their instances then are used instead of direct references provided by the compiler. In C++ class instances can be passed-by-value and hence reference structure could be described by normal classes. (Notice that in Java it is not possible.) For example, account identifiers could be described as follows:
<pre>public <b>class</b> AccountRef { 
        String accNo; 
        ... 
    }</pre>
In order to create a new instance of account object, it is actually necessary to create two instances: one reference and one object. And hence it is necessary to provide two class names. However, to work properly, a reference class has to know about the object class. To pass this information, smart pointers use the mechanism of templates. Specifically, a reference class is defined as a template parameterized by the name of the objects class:
<pre><b>template</b> &lt; class T &gt; 
public <b>class</b> AccountRef { 
        String accNo; 
        T&amp; operator-&gt;() const { ... }  // Access operator 
        ... 
    }</pre>
Thus smart pointer class does not know its concrete object class. Rather, it has a parameter that may take any value. In other words, a smart pointer class can be used to represent any object and one object can be represented by many reference classes. This pairing is performed when a new variable is declared, i.e., for each new variable we provide two concrete class names: one for the reference class and one for the object class:
<pre>AccountRef &lt; Account &gt; account(new Account);</pre>
This variable will store an instance of AccountRef parameterized for Account. Any operation is then applied to this smart pointer which overloads access operator (dot or arrow). Using this smart pointer we can transparently call methods of the represented object, say, account.getBalance(). Here we see that both COP and smart pointers allow the programmer to define custom references with arbitrary structure and behaviour which can be used as intermediate object representatives.

<b>3. Comparison </b>

Although these two approaches look very similar, they are actually quite different.
<ul>
 	<li>Smart pointers is a technique or pattern that can be used only if templates are supported and the language permits pass-by-value semantics for objects. On the other hand, COP is a general purpose approach rather than a reference modelling technique.</li>
 	<li>Concepts in COP are intended to describe hierarchical virtual address spaces where objects will live while smart pointers play the role of interceptors for objects.</li>
 	<li>Smart pointers still use normal classes for modelling references by adapting them for certain purpose. So it is an implementation of some logic of behaviour. In COP, a new programming construct is used instead of classes which intrinsically supports the necessary functions rather than implements them by user-defined methods.</li>
 	<li>Reference class and object class in smart pointers are defined separately and can be then paired almost arbitrarily for specifying what object class has to be represented by what reference class. In COP, reference class and object class do not exist separately because they are parts of one construct. In this sense a reference class and object class are designed together from the very beginning and they cannot be freely paired.</li>
 	<li>Smart pointers assume that reference class and object class are paired many times when each new variable is declared (the problem of duplicated code). In COP, they are paired only once when the concept is defined while variables are declared using one concept name.</li>
 	<li>It is difficult to implement layered (hierarchical) references using smart pointers. In COP it is very easy and, moreover, COP is designed to describe hierarchies using <a href="http://conceptoriented.org/wiki/Inclusion_(concept-oriented_programming)">inclusion relation</a> between concepts.</li>
 	<li>In COP, references can be reused by their child concepts. In other words, we can develop a concept which implements in its reference class some logic of indirect representation and then use it as a base concept for other concepts.</li>
 	<li>Smart smart pointers need special operators in language to distinguish by-value and by-reference semantics (like star and ampersand in C++) because classes to not have this role. In COP, the role of reference and object is built into concept.</li>
</ul>
--
<a href="http://conceptoriented.org"> http://conceptoriented.org</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[1. Modelling references in COP  In the concept-oriented programming (CoP) concepts are used instead of classes. A concept is a pair consisting of one reference class and one object class. Instances of the reference class are passed-by-value and are i&hellip;]]></excerpt:encoded>
		<wp:post_id>18</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:04:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:04:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[concept-oriented-programming-and-smart-pointers]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Modelling hierarchical address space in the concept-oriented programming (COP)</title>
		<link>http://conceptoriented.org/blogs/?p=19</link>
		<pubDate>Sat, 29 Nov 2008 14:05:41 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<b>1.</b>
Let us assume that objects are represented by references in a custom format defined by the programmer. For example, bank accounts could be represented by their numbers. In the <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP) a special construct, called <a href="http://conceptoriented.org/wiki/Concept_(concept-oriented_programming)">concept</a>, is used for this purpose. Concept is a pair of two classes -- one reference class and one object class. With the empty reference class, concept is equivalent to normal classes as used in OOP. However, below we ignore properties of the object class and discuss only role of the reference class -- precisely what distinguishes concepts from conventional classes.

Reference class in concepts is a mechanism for defining custom references of objects. For example, if we need to represent account objects by account numbers (rather than by native references) then the reference class has one field which stores this account number:
<pre><b>concept</b> Account 
    <b>reference</b> { 
        String accNo; 
        ... 
    } 
    <b>object</b> { 
        double balance; 
        ... 
    }</pre>
Notice that the name is assigned to the whole concept, i.e., to the pair of one object class and one reference class, which essentially loose their role as separate constructs and work only together in close cooperation. In other words, we do not define separately a reference class but rather simultaneously two classes with one name. It is a very important feature of the whole concept-oriented paradigm.

Now, if we use concept <code>Account</code> for declaring type of variables then accounts will be stored and passed by means of their numbers rather than using native references like memory address in C++:
<pre>Account account = getAccount("Alexandr Savinov"); // Account number</pre>
Here variable <code>account</code> stores an account number. If <code>Account</code> were a normal class then it would store a native reference. Thus object representation and access in COP is <i>indirect</i>.

<b>2.</b>
Using one concept (or one class) we can define a <i>flat</i> address spaces where objects of one class are represented by references of the associated class (reference class from the concept). Yet frequently we need to describe a <i>hierarchical</i> address spaces where a reference is only one segment in the address. In other words, each segment in a hierarchical address specifies a relative position of the object with respect to the parent segment which in turn is a relative position with respect to its own parent segment and so on till the root of the address space. Such address space is analogous to ordinary postal addresses.

For modelling such hierarchical spaces, COP uses <a href="http://conceptoriented.org/wiki/Inclusion_(concept-oriented_programming)">inclusion relation</a>, which generalizes class inheritance just as concepts generalize classes. Parent address space for this concept is specified by including it into some parent concept. For example, bank account numbers are only relative identifiers which make sense only in one bank. Hence, if we want to deal with accounts of different banks then it is necessary to define two-segment addresses where first (high) segment is bank code and the second (low) segment is account number within this bank. This can be easily done in COP as follows:
<pre><b>concept</b> Bank 
    <b>reference</b> { 
        String bankCode; 
        ... 
    } 
    <b>object</b> { 
        String name; 
        ... 
    } 
    
<b>concept</b> Account <b>in</b> Bank ...</pre>
Notice that concept <code>Account</code> is included into parent concept <code>Bank</code>. As a consequence, references to bank accounts will 'inherit' all fields from the parent reference (yet, it is not so for objects). Such references are referred to as <a href="http://conceptoriented.org/wiki/Complex_reference">complex references</a>. Now if we declare a variable of type <code>Account</code>, it will store two segments taken from reference classes of two concepts:
<pre>Account account = getAccount("Alexandr Savinov"); // Bank code + Account number</pre>
<b>3.</b>
This hierarchical address space can be further extended in the other direction. Assume that bank accounts have sub-accounts like savings accounts or checking accounts, which are defined only with respect to the main account. To represent and access such objects it is necessary to provide bank code, main account number and finally sub-account number. Again this can be done by including child concept into concept <code>Account</code>:
<pre><b>concept</b> SavingsAccount <b>in</b> Account 
    <b>reference</b> { 
        String subAccNo; 
        ... 
    } 
    <b>object</b> { 
        double balance; 
        ... 
    } 
    
<b>concept</b> CheckingAccount <b>in</b> Account 
    <b>reference</b> { 
        String subAccNo; 
        ... 
    } 
    <b>object</b> { 
        double balance; 
        ... 
    }</pre>
If we declare a variable of this more specific type then it will store references consisting of three segments:
<pre>SavingsAccount savingsAccount; // Bank + Account + SavingsAccount 
CheckingAccount checkingAccount; // Bank + Account + CheckingAccount</pre>
<b>4.</b>
Notice that references stored in these variables do not contain any information on the real location of the represented objects. This means that these objects can be anywhere in the world: on disk/tape in the bank, in a database, on CD, in global/local heap, on board of International Space Station or on Mars. This is why objects in COP are said to be represented <i>indirectly</i> and the whole approach is devoted to providing means for <i>indirect</i> object representation and access (ORA).

However, in the program we manipulate objects as if they were <i>directly</i> accessible objects in OOP. In other words, we have a complete illusion of direct access because we still can apply methods to such references or access them in any other way. For example, we might get account balance, <code>account.getBalance()</code>, and here we do not care what kind of reference is stored in the variable and used for access. Thus use of objects does not depend on their representation method. If later we change the way objects are represented then the code that uses these objects remains the same.

Another important property is that inclusion is significantly different from inheritance. The thing is that inclusion means that a child element IS-IN a parent element at run-time, i.e., one parent (base) may have many children (extensions). In OOP inheritance means that a child IS-A parent element and hence extensions and bases are in one-to-one relationship. In COP elements (objects and references) exist within a hierarchy at run-time where extensions have their own references and may share base elements. Local reference of an extension allows distinguishing it from other extensions within this base element.

The third point is that complex references need not to start from the root. If we were using inheritance for describing complex references (for inheriting base segments of the address) then all references would have global scope. In COP it is possible to control the length (and hence scope) of references by choosing the starting segment type. It is very useful feature if we know that some reference will be used only in a restricted context. For example, it is obviously not necessary to store bank reference segment if the account is used within this bank only. This mechanism of reference length control will be described in future posts.

--
<a href="http://conceptoriented.org"> http://conceptoriented.org</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[1. Let us assume that objects are represented by references in a custom format defined by the programmer. For example, bank accounts could be represented by their numbers. In the concept-oriented programming (COP) a special construct, called concept, i&hellip;]]></excerpt:encoded>
		<wp:post_id>19</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:05:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:05:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[modelling-hierarchical-address-space-in-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Concept-oriented programming vs. aspect-oriented programming</title>
		<link>http://conceptoriented.org/blogs/?p=20</link>
		<pubDate>Sat, 29 Nov 2008 14:07:46 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://conceptoriented.org/wiki/Concept-oriented_programming"> Concept-oriented programming</a> (COP) is based on using <a href="http://conceptoriented.org/wiki/Concept_(concept-oriented_programming)">concepts</a> as the main programming construct while <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">aspect-oriented programming</a> (AOP) uses aspects. Although they are two almost completely different programming paradigms proceeding from their own general assumptions, it is still interesting to figure out how they relate. As usual there exist many alternative dimensions along which two methods can be compared. But here we consider only one very general issue which demonstrates how different these two approaches are.

Let us assume that the system consists of several modules such as classes (OOP), concepts (COP) or aspects (AOP). Each module contains some state and/or functionality and they can use each other in one or another way. Modules are developed and added to the system sequentially so that initial modules are unaware of the modules that will be added later while new modules know the existing ones and can use their functions. In our example we can assume that there is one initial module called <code>Base</code> (base class or base concept) and several new modules <code>Ext1</code>, <code>Ext2</code> and <code>Ext3</code> (extensions) which are developed later and can use functions of <code>Base</code>. We say that <code>Base</code> is independent module while the other three modules depend on it.

Assume now that module <code>Base</code> contains some common functionality that needs to be <i>automatically</i> spread over some other modules such as <code>Ext1</code>, <code>Ext2</code> and <code>Ext3</code> by implicitly modifying their behaviour. In AOP, this functionality is said to be <i>injected</i> from the source module <code>Base</code> into target modules <code>Ext1</code>, <code>Ext2</code> and <code>Ext3</code>. However, the most important thing is that the description of injection is part of the base module, i.e., module <code>Base</code> indicates the target modules where its functions have to be injected. This could be written as follows:
<pre><b>module</b> Base <b>inject_into</b> Ext1, Ext2, Ext3 ...</pre>
Notice that we can define a module with its injection targets even if these targets are not yet defined, i.e., we use a kind of forward links to something unknown that will be added later.

In fact, in AOP injected code is defined using pieces of code called <i>advices</i>. And injection of advices is performed into special points during program execution called <i>join points</i> which are grouped into so called <i>point cuts</i> by means of some language. Therefore the following code is more realistic (although it is not any existing language) but it does not change the nature of the AOP approach we want to demonstrate:
<pre><b>aspect</b> Base { 
    <b>pointcut</b> MyPointcut : Ext1::*, Ext2::*, Ext3::someMethod(); 
    <b>before</b> : MyPointcut { print("Injected intermediate function."); } 
}</pre>
This aspect means that before any method described in the pointcut is called, the specified advice will automatically intervene and print something.

In any case, it is the base module that knows the target modules while target modules are completely unaware of when and how their behaviour will be changed. In other words, from the definition of a new module, say, <code>Ext3</code>, it is not possible to determine whether its functions will be modified by other modules (aspects). On the other hand, if we take a base module (aspect) then its definition contains a specification of all target modules that will be influenced.

In contrast, COP uses the conventional direction for this dependence where target modules themselves specify how their behaviour has to be changed by source modules. In other words, a base module is completely unaware where and how its common functions are injected or otherwise used because it is a responsibility of target modules to specify source (base) module that has to implicitly change their behaviour. This can be written as follows:
<pre><b>module</b> Ext1 <b>injects_from</b> Base ... 
<b>module</b> Ext2 <b>injects_from</b> Base ...
<b>module</b> Ext3 <b>injects_from</b> Base ...</pre>
In fact, COP uses <a href="http://conceptoriented.org/wiki/Inclusion_(concept-oriented_programming)">inclusion relation</a> which generalizes inheritance (just as concepts generalize classes) so the previous code is written as follows:
<pre><b>concept</b> Ext1 <b>in</b> Base ... 
<b>concept</b> Ext2 <b>in</b> Base ...
<b>concept</b> Ext3 <b>in</b> Base ...</pre>
Inclusion means putting into the base space or environment which will implicitly change the behaviour of this concept, i.e., an environment (base concept) can affect functionality of its internal components. Yet it is the responsibility of internal components to specify a base environment where they want to live. As a new concept is developed, we need to provide an environment for it by including into some existing concept. In contrast, in AOP an environment has to specify all internal components into which its functions will be injected.

Thus we see that COP and AOP use opposite directions for declaring code injection dependencies. In COP the conventional direction is used (actually, the same as in OOP) where base modules can be developed independently of what will be added later while in AOP code injection is analogous to forward links to what may does not exist yet. This distinction is described in <a href="http://conceptoriented.org/savinov/publicat/imi-report_07.pdf">this</a> paper, Section 9, page 39 (Fig. 17).

--
<a href="http://conceptoriented.org"> http://conceptoriented.org</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[Concept-oriented programming (COP) is based on using concepts as the main programming construct while aspect-oriented programming (AOP) uses aspects. Although they are two almost completely different programming paradigms proceeding from their own genera&hellip;]]></excerpt:encoded>
		<wp:post_id>20</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:07:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:07:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[concept-oriented-programming-vs-aspect-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Two versions of the concept-oriented programming: COP-I and COP-II</title>
		<link>http://conceptoriented.org/blogs/?p=21</link>
		<pubDate>Sat, 29 Nov 2008 14:12:22 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://conceptoriented.org/wiki/Concept_(concept-oriented_programming)">Concept</a> is the main programming construct in the <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP) which is defined as a pair of two classes: one <i>reference class</i> and one <i>object class</i>. The object class describes structure and functions of <i>objects</i> which are passed-by-reference. The reference class describes structure and functions of <i>references</i> which are passed-by-value and represent objects. Thus we distinguish two kinds of things: (i) objects characterized by some identifiers and (ii) references representing and providing access to objects. These two kinds of things are connected by the 'represents' (or 'represented by') relation. Then the following question arises: <b>how objects and references of different concepts relate to each other, i.e., who represents whom</b>.

Taking into account some natural constraints, there exist the following major alternatives:
<ul>
 	<li><b>COP-I: </b> Objects of a concept are <i>represented by</i> references of the parent concept. Or, equally, references of a concept <i>represent</i> objects of the child concepts.</li>
 	<li><b>COP-II: </b> Objects of a concept are <i>represented by</i> references of this same concept. Or, equally, references of a concept <i>represent</i> objects of this same concept.</li>
</ul>
For example, let us assume that we want to describe account objects and account references using concepts. Using COP-I it will be written as follows:
<pre><b>concept</b> Bank 
  <b>object</b> { 
    ...
  }
  <b>reference</b> { // Represents objects of child concepts (Account, ...) 
    String accountNumber; 
    ...
  }

<b>concept</b> Account in Bank 
  <b>object</b> { // Represented by references of the parent concept (Bank) 
    double balance; 
    ...
  }
  <b>reference</b> { 
    ...
  }</pre>
Notice that here we need two concepts. References of the Bank concept represent objects of the Account concept. Thus concept is used to describe a class of objects along with the references used to represented <i>internal</i> objects existing in this context. For each object of the concept there exist many references of this concept (created to represent child objects). Essentially concepts are used to describe containers with their own internal identifiers. It is one of the main design goals of COP-I which is described in the following paper: <a href="http://conceptoriented.org/savinov/publicat/csjm_05.pdf">http://conceptoriented.org/savinov/publicat/csjm_05.pdf </a>.

The following example demonstrates how the same can be written in COP-II:
<pre><b>concept</b> Account 
  <b>reference</b> { // Represents objects of this concept (below) 
    String accountNumber; 
    ...
  }
  <b>object</b> { // Represented by references of this concept (above) 
    double balance; 
    ...
  }</pre>
Here one and the same concept describes both objects and references used to represent them. There is one-to-one correspondence between references and objects of one concept. This approach is described in this paper: <a href="http://conceptoriented.org/savinov/publicat/imi-report_07.pdf">http://conceptoriented.org/savinov/publicat/imi-report_07.pdf</a>.

To (visually) distinguish these two approaches we change the order in which object class and reference class are written in the concept definition. In COP-I we write the object class and then the reference class (first example). In COP-II we write the reference class and then the object class (second example).

<a href="http://conceptoriented.org">The Concept-Oriented Portal</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[Concept is the main programming construct in the concept-oriented programming (COP) which is defined as a pair of two classes: one reference class and one object class. The object class describes structure and functions of objects which are passed-by-ref&hellip;]]></excerpt:encoded>
		<wp:post_id>21</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:12:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:12:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[two-versions-of-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Legalizing references and their duality to objects</title>
		<link>http://conceptoriented.org/blogs/?p=22</link>
		<pubDate>Sat, 29 Nov 2008 14:14:18 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[One of the main principles of the concept-oriented paradigm is that of <i>duality</i>. One of its consequences is that an element is described using two classes: a reference class and an object class. And instead of a single world of objects in OOP, we get a new world consisting of the realm of references and the realm of objects. An object is considered a <i>thing in itself</i> which is not directly accessible. A reference on the other hand is available directly and provides a mechanism for accessing objects. Thus programming and data management is the process of manipulating references which <i>indirectly</i> represent objects. In this case it is important to <i>legalize reference</i> by making them first class citizens. This particularly means that there have to be means for modelling behaviour of objects <i>and</i> references rather than only objects.

In the concept-oriented paradigm this legalization is performed by introducing <a href="http://c2.com/cgi/wiki?ConceptInCop">concepts</a> as a generalization of conventional classes. Concept is a pair consisting of one reference class and one object class. Instances of the reference class exist in the realm of references. They are passed-by-value and do not have their own references. Instances of the object class exist in the realm of objects. They are passed-by-reference using their representatives from the realm of references. It is important that concepts allow us to model objects and references in their inseparable unity.

Having a reference is the primary and necessary thing for anything that wants to exhibit itself as an <i>existing</i> thing. In other words, without a reference it is simply not possible to let others know that this object does really exist. Thus describing an object in OOP via its object class is not enough for this object to be perceptible and hence useful. In OOP this problem is solved by providing a native class of references which is "inherited" by any other object class. In the <a href="http://c2.com/cgi/wiki?ConceptOrientedProgramming">concept-oriented programming</a> (COP) any object class may declare its own reference class using the new programming construct, called <a href="http://conceptoriented.org/wiki/Concept_%28concept-oriented_programming%29">concept</a>. An important thing here is that the two classes are always defined in pairs and hence we can retain their inseparability and mutual dependence. References provide a front end for the objects they represent while objects may possess some behaviour that needs to be associated with the concrete points in space.]]></content:encoded>
		<excerpt:encoded><![CDATA[One of the main principles of the concept-oriented paradigm is that of duality. One of its consequences is that an element is described using two classes: a reference class and an object class. And instead of a single world of objects in OOP, we get a ne&hellip;]]></excerpt:encoded>
		<wp:post_id>22</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:14:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:14:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[legalizing-references-and-their-duality-to-objects]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>FAQ on the Concept-Oriented Programming</title>
		<link>http://conceptoriented.org/blogs/?p=23</link>
		<pubDate>Sat, 29 Nov 2008 14:16:28 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[A new <a href="http://conceptoriented.org/faqs/cop-faq.html">FAQ</a> has been started in the series of concept-oriented technology FAQs on the <a href="http://conceptoriented.org/">concept-oriented portal</a>. This new <a href="http://conceptoriented.org/faqs/cop-faq.html">FAQ</a> is aimed at answering simple questions on the next generation programming paradigm called the <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP). This new approach is based on a set of principles which are explained in the first section. The main programming construct in COP is a <a href="http://conceptoriented.org/wiki/Concept_(concept-oriented_programming)">concept</a> which generalizes conventional classes. What is a concept, what are its properties and how it is used is described in the second section of the <a href="http://conceptoriented.org/faqs/cop-faq.html">COP FAQ</a>. More information on the concept-oriented programming can be found in the recently published paper which can also be downloaded from the <a href="http://conceptoriented.org/">concept-oriented portal</a>. The portal also provides information on other related concept-oriented technologies such as the concept-oriented data model (COM).]]></content:encoded>
		<excerpt:encoded><![CDATA[A new FAQ has been started in the series of concept-oriented technology FAQs on the concept-oriented portal. This new FAQ is aimed at answering simple questions on the next generation programming paradigm called the concept-oriented programming (CoP). Th&hellip;]]></excerpt:encoded>
		<wp:post_id>23</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:16:28]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:16:28]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[faq-on-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>New wiki devoted to the concept-oriented programming (COP)</title>
		<link>http://conceptoriented.org/blogs/?p=24</link>
		<pubDate>Sat, 29 Nov 2008 14:18:05 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[New <a href="http://conceptoriented.org/wiki/">wiki</a> has been started on the <a href="http://conceptoriented.org/">concept-oriented portal</a>. It contains a number of articles in the style of encyclopaedia defining main terms and notions used in the concept-oriented paradigm. In particular, in includes a category for the <a href="http://conceptoriented.org/wiki/Category:Concept-oriented_programming">concept-oriented programming</a> and a category for the <a href="http://conceptoriented.org/wiki/Category:Concept-oriented_model">concept-oriented data model</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[New wiki has been started on the concept-oriented portal. It contains a number of articles in the style of encyclopaedia defining main terms and notions used in the concept-oriented paradigm. In particular, in includes a category for the concept-oriented&hellip;]]></excerpt:encoded>
		<wp:post_id>24</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:18:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:18:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[new-wiki-devoted-to-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Main principles of the concept-oriented data model</title>
		<link>http://conceptoriented.org/blogs/?p=8</link>
		<pubDate>Fri, 05 Dec 2008 05:54:25 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Concept-oriented model is based on the following main principles:

1. Separation of physical and logical structures [duality]. In COM any elements is defined as a member of two separate structures which are referred to as physical and logical. The physical structure has a hierarchical form and describes how elements are represented and accessed. In particular, it determines the life-cycle of elements, how they are identified and where they are stored physically. Once an element has been created it cannot change its position in the physical structure. The logical structure has a multidimensional hierarchical form where each element has a number of parents and a number of children. Cycles are not permitted and there exist two special elements: the top and the bottom. A list of parents (superelements) is stored as properties of this element and hence it is possible to change them. According to this separation each element is a member of two sets: one is its physical parent while the other are its logical parents.

2. Priority of order of elements [order]. In COM it is of crucial importance how elements are ordered rather than how they are organized into sets. This means that the meaning of any element is determined by its relative position to other elements in the logical structure where it has a number of parents and children. The element itself without its neighbours is meaningless because its position in the physical structure has normally a primitive semantics. In contrast to set-based approaches, in COM elements are ordered and only after that the sets are derived (a set consists of all children of one parent).

3. Managing links rather than elements. Since semantics is determined by the order of elements, the primary concern of any concept-oriented database management system consists in managing this order. This means that the links among elements are more important than the elements themselves.

4. Syntax and semantics. In COM syntax is defined as constraints imposed on possible properties of items imposed by concepts where items are physical children of concepts. Specifically, if a concept has a number of parent concepts (superconcepts) then its items have a syntactic constraint. This constraint means that all items must have superitems from these superconcepts.]]></content:encoded>
		<excerpt:encoded><![CDATA[Concept-oriented model is based on the following main principles: 1. Separation of physical and logical structures [duality]. In CoM any elements is defined as a member of two separate structures which are referred to as physical and logical. The phy&hellip;]]></excerpt:encoded>
		<wp:post_id>8</wp:post_id>
		<wp:post_date><![CDATA[2008-12-05 05:54:25]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-12-05 05:54:25]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[main-principles-of-the-concept-oriented-data-model]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="com"><![CDATA[com]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Concept-oriented model: unifying domain and relation modeling</title>
		<link>http://conceptoriented.org/blogs/?p=9</link>
		<pubDate>Sun, 21 Oct 2012 13:47:17 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[The <a href="http://conceptoriented.org/wiki/Concept-oriented_model">concept-oriented model</a> (COM) of data is a general-purpose unified model. In this post we describe one aspect of this model. More specifically, we describe how this model can unite two branches currently existing in computer science: value or domain modeling and relation modeling. It is achieved by introducing a new data modeling and programming construct, called concept, which is used for typing both domains and relations. 

<strong>1. Relations and domains</strong>

In the relational model, a domain is a set of <em>values</em> and a tuple is a combination of values from some domains. For example, a domain could consist of all integer values like 1, 2, 3 and so on. 

A relation is defined over some domains via its schema and tuples. A relation schema is a number of domains for the relation attributes which are also called attribute types. Relation tuples are composed of values taken from these domains. For example, a ColorTable could be defined as a set of triples each composed of three integers taken from one domain. To define a new relation we have to specify domains for its attributes. 

This classical approach clearly separates relations from domains. Here relations and domains are modeled differently by using different modeling constructs and patterns. Data modeling is broken into two isolated areas: relation modeling and domain (or value) modeling. Relations are normally modeled using the relational model while domains are modeled using object-oriented methods. For instance, domains can be extended. In figures, relations will be shown in light blue color and domains will be shown in light green color. 

<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/domain-modeling-1.png" alt="Relations and domains" title="Concept-oriented model: unifying domain and relation modeling. Relations and domains" width="85%" /></div>

<br />
<strong>2. Complex values</strong>

Domains can be used not only to define relations. They also can be used to define <em>complex domains</em> which are sets of complex values. A complex value is a combination of several simpler values taken from other domains. Thus complex values may have arbitrary structure which is defined in terms of existing domains. For example, we could define a new domain for colors where one value is composed of three integers. It is very similar to how we have defined a new color relation except that now colors are represented as <em>values</em> within a domain rather than <em>tuples</em> within a relation. 

These complex values can now be used in relations as if they were primitive values. For instance, the ColorTable could have an attribute with the type of the complex domain. 

Thus complex domains (also known as user-defined types) allow us to model domains with arbitrary structure. And these complex domains can be then used to define relations. 

<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/domain-modeling-2.png" alt="Complex values" title="Concept-oriented model: unifying domain and relation modeling. Complex values" width="85%" /></div>

<br />
<strong>3. Problem</strong>

So existing domains can be used to define either new relations or new domains. In other words, relations and domains are defined in terms of already existing domains. 

The problem here is that 

<blockquote>it is not possible to use <em>existing</em> relations when defining new relations or domains</blockquote>

Attributes in both domains and relations are typed using only domains and there is no possibility to have relation-typed attributes. Thus relations and domains are not only isolated but they are also <em>asymmetric</em> in their use because only domains are used when extending a schema. 

Another problem is that relations cannot be extended like domains using the traditional object-oriented approach. For example, we can extend the <em>domain</em> People when defining a new domain Employees by adding more specific attributes but we cannot naturally extend the <em>relation</em> People by introducing a new relation Employees. 

There exist some solutions to this problem. 
<ul>
<li>One consists in introducing objects, which are modeled by classes, instead of using tuples and relations. In contrast to relations, classes <em>can</em> be used as attribute types. In this approach however we will not be able to model custom references with arbitrary structure. In addition, this essentially means switching to the object-oriented approach which has always been controversial in data modeling. For example, it is not very suitable for set-oriented operations. </li>
<li>Another solution consists in using foreign keys. Yet, foreign key is not a type ‚Äì it is a constraint. Therefore it can be used as a pattern or workaround but not as a principled solution. </li>
</ul>

Our goal is to make relations and domains absolutely symmetric. So the main question is whether it is possible to <em>combine</em> relation modeling and domain modeling, by making them symmetric with respect to each other, as well as integral parts of one construct. Obviously, it is a quite non-trivial problem which touches the foundations of not only data modeling but also other branches of computer science. 

<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/domain-modeling-3.png" alt="Problem with relations and domains" title="Concept-oriented model: unifying domain and relation modeling. Problem with relations and domains" width="85%" /></div>

<br />
<strong>4. Concepts</strong>

The solution provided within the concept-oriented model consists in introducing a new construct, called <em><a href="http://conceptoriented.org/wiki/Concept_(concept-oriented_model)">concept</a></em>:

<blockquote>Concept is defined as a <em>couple</em> of two classes: one identity class and one entity class</blockquote>

Identity and entity classes are also referred to as reference and object classes, respectively, in <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP). The main difference between them is that identities are always values and are passed and stored by-value while entities are passed by-reference. 

Concept instances are identity-entity couples which are informally analogous to complex numbers in mathematics. Indeed, complex numbers also have two constituents but are manipulated as one whole. A domain in this case is defined as a set of identity-entity <em>couples</em> rather than either values or tuples. As a result, there is no need in distinguishing between value domains and relations. Concepts are used instead of both relation types and domain types by unifying relation modeling and value modeling.

Concept-typed attributes contain references in the format of the identity class. Simultaneously, they reference an object in the format of the entity class. In this way we can freely vary between by-value and by-reference constituents of data. If a concept has empty entity class then its instances are values. If a concept has empty identity class then its instances are represented by primitive references like objects. 

<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/domain-modeling-4.png" alt="Concepts" title="Concept-oriented model: unifying domain and relation modeling. Concepts" width="85%" /></div>

<br />
<strong>5. Conclusion</strong>

In summary, concepts in the concept-oriented model allow us to <em>unify</em> domain and relation modeling by using only one construct for both purposes. Concepts provide a type-based mechanism for modeling domain-specific references or foreign keys. It is also important that concepts generalize conventional classes and are used also in <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a>. 

More information on the concept-oriented model and concept-oriented programming can be found on this site: http://conceptoriented.org

<strong>Links</strong>

1. Concept-oriented model: unifying domain and relation modeling. <a href="http://www.youtube.com/watch?v=dh_6AeQB6Gc&amp;feature=colike">Youtube video</a>

2. Concept-oriented model: unifying domain and relation modeling. <a href="http://www.slideshare.net/asavinov/conceptoriented-model-unifying-domain-and-relation-modeling">Slideshare slides</a>

3. A. Savinov, <a href="http://www.cisjournal.org/journalofcomputing/Download_April_pdf_1.aspx">Concept-Oriented Model: Classes, Hierarchies and References Revisited</a>, Journal of Emerging Trends in Computing and Information Sciences 3(4), 456-470, 2012. <a href="http://www.cisjournal.org/journalofcomputing/archive/vol3no4/vol3no4_1.pdf">PDF</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[The concept-oriented model (COM) of data is a novel general-purpose unified model. In this post we describe one aspect of this model. More specifically, we describe how this model can unite two branches currently existing in computer science: value or domain modeling and relation modeling. It is achieved by introducing a new data modeling and programming construct, called concept, which is used for typing both domains and relations.]]></excerpt:encoded>
		<wp:post_id>9</wp:post_id>
		<wp:post_date><![CDATA[2012-10-21 13:47:17]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2012-10-21 13:47:17]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[concept-oriented-model-unifying-domain-and-relation-modeling]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codeproject"><![CDATA[CodeProject]]></category>
		<category domain="category" nicename="com"><![CDATA[com]]></category>
		<category domain="post_tag" nicename="concept"><![CDATA[concept]]></category>
		<category domain="post_tag" nicename="concept-oriented-model"><![CDATA[concept-oriented model]]></category>
		<category domain="post_tag" nicename="domain-modeling"><![CDATA[domain modeling]]></category>
		<category domain="post_tag" nicename="relation-modeling"><![CDATA[relation modeling]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<category domain="post_tag" nicename="unified-model"><![CDATA[unified model]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>New paper on the concept-oriented data model</title>
		<link>http://conceptoriented.org/blogs/?p=25</link>
		<pubDate>Sat, 29 Nov 2008 14:19:07 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<b>Two-Level Concept-Oriented Data Model</b>

Abstract

In this paper we describe a new approach to data modelling called the concept-oriented model (CoM). This model is based on the formalism of nested ordered sets which uses inclusion relation to produce hierarchical structure of sets and ordering relation to produce multi-dimensional structure among its elements. Nested ordered set is defined as an ordered set where an each element can be itself an ordered set. Ordering relation in CoM is used to define data semantics and operations with data such as projection and de-projection. This data model can be applied to very different problems and the paper describes some its uses such grouping with aggregation and multi-dimensional analysis.

Table of contents:

1 Introduction 2
2 One-Level Data Model 3
2.1 Labelled Ordered Sets 3
2.2 Interpretations of Ordering Relation 6
2.3 Representation of Labelled Ordered Sets 8
2.4 Operations with Elements 10
3 Two-Level Data Model 11
3.1 Nested Ordered Sets 11
3.2 Syntactic Constraints 12
3.3 Multidimensional Hierarchical Space 14
4 Operations with Model Semantics 16
4.1 Representing Model Semantics 16
4.2 Projection and De-Projection 19
4.3 Constraints and their Propagation 21
4.4 Dependencies and Inference 25
5 Uses of the Model 26
5.1 Query Language 26
5.2 Multi-Valued Properties 29
5.3 Grouping and Aggregation 30
5.4 Multi-Dimensional Analysis and OLAP 33
6 Related Work 35
7 Conclusions 38
8 References 38

This and other papers can be downloaded from <a href="http://conceptoriented.org"> http://conceptoriented.org</a> (section Publications) or directly <a href="http://conceptoriented.org/savinov/publicat/imi-report_07_3.pdf">here</a>.]]></content:encoded>
		<excerpt:encoded><![CDATA[Two-Level Concept-Oriented Data ModelAbstractIn this paper we describe a new approach to data modelling called the concept-oriented model (CoM). This model is based on the formalism of nested ordered sets which uses inclusion relation to produce&hellip;]]></excerpt:encoded>
		<wp:post_id>25</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:19:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:19:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[new-paper-on-the-concept-oriented-data-model]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Informal Introduction into the Concept-Oriented Programming</title>
		<link>http://conceptoriented.org/blogs/?p=26</link>
		<pubDate>Sat, 29 Nov 2008 14:21:02 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<b>Title:</b> <a href="http://conceptoriented.org/papers/CopInformalIntroduction.html">Informal Introduction into the Concept-Oriented Programming</a>

<b>Absract:</b> This paper describes a new approach to programming, called the concept-oriented programming (COP). It is based on using a new programming construct, called <a href="http://conceptoriented.org/wiki/Concept_%28concept-oriented_programming%29">concept</a>, which generalizes conventional classes. Concepts describe behaviour of both objects and references. Hence references are completely legalized and made first-class citizens with the same rights as objects. Using concepts the programmer can easily describe custom virtual address spaces where objects will exist. The hierarchical structure of such a space is modelled by means of concept <a href="http://conceptoriented.org/wiki/Inclusion_%28concept-oriented_programming%29">inclusion relation</a> which generalizes class inheritance. In COP, a great deal or even most of functions are executed implicitly during object access rather than in target objects themselves. These functions have cross-cutting nature but can be effectively separated using COP.

<b>COP Wiki:</b> <a href="http://conceptoriented.org/wiki/Category:Concept-oriented_programming">http://conceptoriented.org/wiki/Category:Concept-oriented_programming</a>

<b>COP FAQ:</b> <a href="http://conceptoriented.org/faqs/cop-faq.html">http://conceptoriented.org/faqs/cop-faq.html</a>

<b>COP forum:</b> <a href="http://conceptoriented.org/forums/index.php">http://conceptoriented.org/forums/index.php</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[Title: Informal Introduction into the Concept-Oriented ProgrammingAbsract: This paper describes a new approach to programming, called the concept-oriented programming (CoP). It is based on using a new programming construct, called concept, which gene&hellip;]]></excerpt:encoded>
		<wp:post_id>26</wp:post_id>
		<wp:post_date><![CDATA[2008-11-29 14:21:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-11-29 14:21:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[informal-introduction-into-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Main principles of the concept-oriented programming</title>
		<link>http://conceptoriented.org/blogs/?p=27</link>
		<pubDate>Fri, 05 Dec 2008 05:55:45 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[1. Separation of business methods (BMs) and representation and access (RA) methods. Business methods are target methods of objects which are called explicitly in the source code. Representation and access methods are called implicitly when objects are being accessed. In other words, when some BM is called a sequence of some RA methods is executed behind the scenes and hence RA methods represent a hidden layer of functionality. A programming paradigm should provide means for describing both types of functionality.

2. Objects live in spaces and any BM call has to intersect a sequence of borders in order to access the object. When an access request intersects a space border on its way to the target object some intermediate RA functionality is triggered automatically and implicitly. This hidden intermediate functionality concentrated on space borders accounts for a great deal and even most of the system complexity. Describing this functionality is as important as describing target BMs.

3. The spaces where objects live have a hierarchical structure. This structure is precisely what is called physical structure in the concept-oriented data model. Thus an object has an environment where it lives; this environment has its own environment and so on up to the root of the (physical) hierarchy.

4. Transparency of access. Here the idea is that BMs should be called impendent of the target object representation and access mechanism and the object real position. All these peculiarities should be hidden because they belong to another layer of functionality. On the other hand, since instant call is only a useful abstraction it is necessary to provide a mechanism for specifying what happens behind the scenes. Thus the illusion of instant access is provided along with means for describing intermediate functionality that belongs to the hidden RA layer and activated automatically.]]></content:encoded>
		<excerpt:encoded><![CDATA[1. Separation of business methods (BMs) and representation and access (RA) methods. Business methods are target methods of objects which are called explicitly in the source code. Representation and access methods are called implicitly when objects are be&hellip;]]></excerpt:encoded>
		<wp:post_id>27</wp:post_id>
		<wp:post_date><![CDATA[2008-12-05 05:55:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-12-05 05:55:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[main-principles-of-the-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Modelling references</title>
		<link>http://conceptoriented.org/blogs/?p=28</link>
		<pubDate>Fri, 05 Dec 2008 06:02:48 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[One of the main concerns in the concept-oriented paradigm is <i>representation and access</i> (RA). Its importance is a consequence of another concept-oriented principle which says that a great deal of any complex system functionality is executed behind the scenes during object access. This hidden functionality is associated with references or other types of identifiers (as opposed to objects). In the concept-oriented programming (COP) the system functionality is divided on two types: (i) conventional business methods (BMs), and (ii) intermediate representation and access (RA) methods. An amazing feature of the concept-oriented programming is that it allows us to describe both sides of any system simultaneously. And the main solution consists in using a new programming construct called <i>concept</i>.

Concept consists of two parts: an object class and a reference class. Instances of the object class, called objects, are passed by reference. Instances of the reference class, called references, are passed by value. Thus we get two worlds which co-exist in any system: the world of objects and the world of references. Currently, there are a lot of methods for modelling objects and their functions. However, there are no methods for modelling references. Indeed, what if I want to define my own format for identifying objects in my program? I need to invent some special tricks or use non-standard patterns because no general solution currently exists. And it is precisely where we can use concepts with their reference classes which are intended to describe the format of references and their functions.

For example, if my objects need to be represented by integers then I define this field in the reference class:
<pre><b>concept</b> Indirect 
  <b>class</b> { 
    static Map map.create(); 
  }
  <b>reference</b> { 
    int id; // Object identifier 
  }
</pre>
After that I add a special method for resolving this reference:
<pre><b>concept</b> Indirect 
  <b>class</b> { 
    static Map map.create(); 
  }
  <b>reference</b> { 
    int id; // Object identifiers 
    void <b>continue</b>() { // Continuation method 
      System.out.println("&gt; Begin resolution"); 
      Object o = context.map.get(id); // Resolve reference 
      o.<b>continue</b>(); // Invoke target method 
      System.out.println("&gt; End resolution"); 
    }
  }
</pre>
Finally, any target class can be included into this concept using keyword 'in' and all its instances will be automatically represented by integers:
<pre>class Customer <b>in</b> Indirect { ... } 
<b>class</b> Product <b>in</b> Indirect { ... } 

<b>class</b> Source { 
  void myMethod(Customer c, Product p) { 
    ... 
    String name = customer.getName(); 
    ... 
    double price = product.getPrice (); 
    ... 
  } 
}
</pre>
Here two parameters to myMethod are indirect references defined in concept Indirect. More specifically, they are integers because concept Indirect is a parent of classes Customer and Product. For example, if a method of the target class will be called then the compiler will automatically wrap it in the appropriate intermediate method of the parent concept. This method when called will generate the following output:
<pre>$ &gt; Begin resolution 
$ *** Here Customer::getName() is called 
$ &gt; End resolution 
$ &gt; Begin resolution 
$ *** Here Product::getPrice() is called 
$ &gt; End resolution 
</pre>
An advantage of this approach is that objects and methods are used as usual, i.e., it retains the illusion of instant access independent of how objects are represented and access. This method guarantees that the intermediate procedures will always be executed and hence the logic of RA is ensured. It allows us to define nested indirection where a reference substitutes for another reference and so on till the system format of references. And it is possible to define hierarchical references consisting of several segments like a postal address. Objects in this case can reside anywhere in the world but we can still use them as usual. Thus programming in this paradigm is aimed at modelling references and their functions rather than only objects.]]></content:encoded>
		<excerpt:encoded><![CDATA[One of the main concerns in the concept-oriented paradigm is representation and access (RA). Its importance is a consequence of another concept-oriented principle which says that a great deal of any complex system functionality is executed behind the sce&hellip;]]></excerpt:encoded>
		<wp:post_id>28</wp:post_id>
		<wp:post_date><![CDATA[2008-12-05 06:02:48]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2008-12-05 06:02:48]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[modelling-references]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Dark matter of a computer program</title>
		<link>http://conceptoriented.org/blogs/?p=29</link>
		<pubDate>Tue, 17 Feb 2009 05:21:41 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[One interesting observation about computer programs is that something always happens during object access behind the scenes which means that any object access inevitably entails execution of some code which is not part of this program. Thus object access is necessarily indirect because it needs some intermediate procedure which is responsible for finding the real location of the represented object. 

For example, if we have a reference to a bank account object of class <code>Account</code> then it can be accessed as usual by calling its methods:

<pre>  Account account = findAccount("Alexandr Savinov"); 
  double account.getBalance(); // Object access </pre>

Here one method invocation is responsible for accessing this object and getting the current balance. Although here we have the illusion of instantiations action and direct access, it is wrong to think that getting balance is a kind of primitive operation which is executed immediately after this method has been called. In fact, if it is a Java program then JVM will have to resolve this reference into memory handle which in turn will have to be locked and a physical address will be obtained. If it is a remote reference then this request will have to be serialized and transferred over the network using some protocol. It might also happen that this reference represents a persistent object and then its state will have to be retrieved from some storage. There are also many other examples and use cases but the main observation is that 

<blockquote>There is always some intermediate code executed implicitly behind the scenes during object access and this code is referred to as dark matter of the program</blockquote>

<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/dark_matter.png" alt="Dark matter of a computer program" title="Dark matter of a computer program" width="75%" /></div>

Why it is called dark matter of the program universe? Because it is undetectable and we know about its presence only indirectly by observing its effects. The presence of dark matter is inferred from the necessity to explain some "missing functionality" where we see that the program results in some effect but the program code has no instructions which could explain it. Moreover, even if we know that it does really exist we are still not able to affect this layer of functionality using traditional approaches programming. We cannot set the moment in time where this code will be activated. And we are not able to influence what precisely will happen during access. This layer is completely out of control. And here we come to an interesting but rather pessimistic conclusion: 

<blockquote>There exists a layer of functionality which cannot be changed or replaced in OOP </blockquote>

It should be noted that of course we have a possibility to influence how object access works by changing the environment of the program such as the compiler, run-time environment, library, operating system or hardware platform. This will not change the explicitly defined behaviour of the program (business logic) but it will change how references are defined, how objects are accessed and other aspects that cannot be changed from the program itself. In other words, by putting our program in different environments we can change the implicitly executed intermediate functions -- the dark matter. 

So what is the problem? The problem is that we would like to be able to influence dark matter from this same program and for that purpose we need a programming approach which would treat dark matter as integral part of this same program. We would like to be able to develop our own domain specific dark matter which is adapted for the purposes of this specific program and this specific application. Why it is important? Because we accept the following postulate: 

<blockquote>Hidden intermediate functions executed during object access are as important as normal explicitly invoked object methods and they can account for a great deal of even most of the program complexity </blockquote>

If this assumption is true then the focus of programming moves to developing intermediate functions rather than end object methods. In other words, the shift of paradigm is that it is more important what happens in-between than what happens at the end (of method invocation). Any method invocation turns in this case into a sequence of intermediate actions where the method itself is only the last step. Here are some well known examples of functionality which should belong to a different layer invisible from the main layer of business logic and therefore treated as dark matter:

<ul>
<li> Persistent layers. We want to manipulate objects as if they were normal objects but change the way how their state is managed. </li>
<li> Object containers. We want to be able to develop application specific containers where objects will live by retaining the possibility to access them as if they were directly accessible objects. </li>
<li> Custom memory managers. Why to use the standard heap provided by OS if we have a number of application specific requirements for this unit? It would be much more productive to develop our own memory manager which is adapted for objects of this and only this program. </li>
<li> Domain specific compiler. We want to change the way how references and other constructs in our program are implemented. For that purpose we can change the compiler but it is normally either not possible or is very difficult. It would be interesting to have a possibility to develop a compiler/interpreter as an integral part of this same program. </li>
</ul>

To solve this and many other problems a new programming paradigm has been developed -- <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">Concept-Oriented Programming</a> (COP). Within this approach, dark matter plays central role and is made integral part of the program. In COP, the programmer is not only able to influence what happens behind the scenes but rather it is his main concern. In other words, the main task in COP is creating an application specific environment where objects will live. This includes such functionality as object representation (custom references) and object access (custom access procedures). The functionality of this domain specific environment is triggered implicitly by injecting the necessary functions into all internal objects. 

It is important that COP generalizes OOP by retaining its main principles and features. COP introduces a new programming construct, called <a href="http://conceptoriented.org/wiki/Concept_%28concept-oriented_programming%29">concept</a>, which generalizes conventional classes. Concepts in COP exist within a hierarchy defined by means of <a href="http://conceptoriented.org/wiki/Inclusion_%28concept-oriented_programming%29">inclusion relation</a> which generalizes classical inheritance. It is also important that COP allows for describing cross-cutting concerns in a manner which is different from AOP (and even can be said to be opposite to AOP). And what is more, COP is a basis for a new data model -- <a href="http://conceptoriented.org/wiki/Concept-oriented_model">Concept-Oriented Model</a> (COM) -- by significantly decreasing the incompatibility between conventional data and programming models (impedance mismatch). 

Links: 

<ul>
<li><a href="http://conceptoriented.org/papers/CopInformalIntroduction.html">Informal Introduction into the Concept-Oriented Programming</a></li>
<li><a href="http://conceptoriented.org/wiki/Concept-oriented_programming">Concept-Oriented Programming wiki article</a></li>
<li><a href="http://conceptoriented.org/papers/ComInformalIntroduction.html">Informal Introduction into the Concept-Oriented Data Model</a></li>
<li><a href="http://conceptoriented.org/wiki/Concept-oriented_model">Concept-Oriented Model wiki article</a></li>
<li><a href="http://conceptoriented.org/forums/index.php">Concept-oriented discussion forum</a></li>
<li><a href="http://www.theserverside.com/news/thread.tss?thread_id=47699">Discussion on The Server Side</a></li>
<li><a href="http://discuss.joelonsoftware.com/default.asp?joel.3.650579.14">Discussion on The Joel on Software</a></li>
<li><a href="http://c2.com/cgi/wiki?ConceptOrientedModel">Concept-Oriented Model wiki article on c2</a></li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[One interesting observation about computer programs is that something always happens during object access behind the scenes which means that any object access inevitably entails execution of some code which is not part of this program. These intermediate actions executed implicitly are referred to as dark matter of the program. Most conventional approaches to programming do not provide effective means for describing this layer of functionality. To solve this problem a new approach to programming has been developed -- Concept-Oriented Programming (CoP). The focus in CoP shifts to developing intermediate functions rather than end object methods. Within this approach, dark matter plays central role and is made integral part of the program. In CoP, the programmer is not only able to influence what happens behind the scenes but rather it is his main concern. In other words, the main task in CoP is creating domain specific environments where objects will live. CoP generalizes OOP by retaining its main principles and it can be also viewed as an interesting alternative to AOP. CoP introduces a new programming construct, called concept, which generalizes conventional classes, and a new relation, called inclusion relation, which generalizes inheritance.]]></excerpt:encoded>
		<wp:post_id>29</wp:post_id>
		<wp:post_date><![CDATA[2009-02-17 05:21:41]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2009-02-17 05:21:41]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[dark-matter-of-a-computer-program]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="codeproject"><![CDATA[CodeProject]]></category>
		<category domain="post_tag" nicename="concept"><![CDATA[concept]]></category>
		<category domain="post_tag" nicename="concept-oriented-programming"><![CDATA[concept-oriented programming]]></category>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="object"><![CDATA[object]]></category>
		<category domain="post_tag" nicename="object-access"><![CDATA[object access]]></category>
		<category domain="post_tag" nicename="object-representation"><![CDATA[object representation]]></category>
		<category domain="post_tag" nicename="programming-paradigms"><![CDATA[programming paradigms]]></category>
		<category domain="post_tag" nicename="reference"><![CDATA[reference]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>The need in domain-specific references and reference modeling in COP</title>
		<link>http://conceptoriented.org/blogs/?p=30</link>
		<pubDate>Tue, 03 Mar 2009 04:50:01 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/reference_modeling.png" alt="The need in domain-specific references and reference modeling in COP" title="The need in domain-specific references and reference modeling in COP" width="85%" /></div>

As programmers, we know that any object has a representative, called <i>reference</i>. For decades objects have relied exclusively on references provided by the compiler which in turn used the underlying environment, some kind of standard library or middleware for their generation and management. For example, the compiler could use global heap where allocated objects are represented by a system-specific memory handle. Objects could be represented by remote references generated by EJB container like JBoss or WebLogic. In Java, references are generated by JVM. Other interpreters are using their own run-time environment and hence their own specific references. Thus most contemporary programming languages have one common property: 

<blockquote><b>References are <i>not</i> integral part of the program and cannot be adapted to the purposes of this application and this problem domain </b></blockquote>

In other words, in conventional programming languages we are destined to use only <i>standard</i> references and their access mechanisms provided by the available hardware, OS, middleware or library. There is no easy possibility to develop application-specific references for this concrete domain as integral part of this program. 

The system can be then viewed as divided into two layers: <ol>
<li>The first layer is responsible for generating/managing references and providing object access procedure </li> 
<li>The second layer is the program itself where these references are used independent of the peculiarities of the first layer</li>
</ol>

Almost all exiting programming paradigms isolate these two layers so that programming is reduced to the second layer. This means that the programmer can develop objects and their methods but is not able to influence how these objects are represented and how they will be accessed. <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">Concept-oriented programming</a> (COP) is a novel approach to programming which changes this view and allows for describing both layers within one program. COP makes references first-class citizens of the object world by retaining the transparency of access (isolation of the layers). References and objects have equal rights in a concept-oriented program. In particular, COP is based on using a new programming construct, called <a href="http://conceptoriented.org/wiki/Concept_%28concept-oriented_programming%29">concept</a>, which is defined as a couple of two classes: one reference class and one object class. As a consequence, both references and objects have arbitrary domain-specific structure and behaviour. COP also uses <a href="http://conceptoriented.org/wiki/Inclusion_%28concept-oriented_programming%29">inclusion relation</a> instead of classical inheritance. (Concepts and inclusion generalize classes and inheritance, respectively.) 

One of the main advantages of COP is that the programmer can develop domain-specific containers with a virtual address space where objects will live. In other words, the programmer can implement functions which normally belong to hardware, OS, middleware, run-time environment or a library. Another interesting application consists in modeling cross-cutting concerns.]]></content:encoded>
		<excerpt:encoded><![CDATA[Most conventional programming languages provide only standard references and there is no easy possibility to develop domain-specific references for this concrete application as integral part of this program. Concept-oriented programming (CoP) is a novel approach which makes references first-class citizens of the object world so that references and objects have equal rights and both have arbitrary domain-specific structure/behavior.]]></excerpt:encoded>
		<wp:post_id>30</wp:post_id>
		<wp:post_date><![CDATA[2009-03-03 04:50:01]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2009-03-03 04:50:01]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[the-need-in-domain-specific-references-and-reference-modeling-in-cop]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="concept-oriented-programming"><![CDATA[concept-oriented programming]]></category>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="domain-specific-references"><![CDATA[domain-specific references]]></category>
		<category domain="post_tag" nicename="reference-modeling"><![CDATA[reference modeling]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>What if references are active elements of the program?</title>
		<link>http://conceptoriented.org/blogs/?p=31</link>
		<pubDate>Thu, 09 Apr 2009 05:27:10 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[In programming, we used to think of references are something primitive and platform-specific that is provided by the compiler as a means for representing objects. In contrast to objects, which have domain-specific structure and behavior, references do not expose their structure and do not show any activity. We use objects represented by references as if they were directly accessible and programming is reduced to modeling exclusively objects while references are absolutely passive elements.

But what if we assume that references, like objects, may have arbitrary domain-specific structure and behavior? Shortly, we will get a novel approach, called <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP). References in COP are as important as objects because <i>both</i> can modularize domain-specific structure and behavior. The first question here is what advantages we will get by using active references? Here are some applications where it could be useful:
<ul>
 	<li>Modeling <a href="http://conceptoriented.org/blogs/cob/2007/06/12/modelling-hierarchical-address-space-in">domain-specific address space</a> rather than adapting platform-specific surrogates. Indeed, why not to use domain-specific references directly in the program to identify its objects? It is simpler and more natural.</li>
 	<li>Modeling <a href="http://conceptoriented.org/blogs/cob/2007/05/29/concept-oriented-programming-vs-aspect-o">cross-cutting concerns</a>. An important observation about references is that their functions cross-cut many classes of objects. For example, when a Java object is being accessed, JVM executes one and the same procedure independent of the object class. If references could be modeled from the program then we could use them to execute functions which are common to many object classes.</li>
 	<li>Modeling persistent, remote and transactional objects. References could be responsible for implementing intermediate functionality which is specific to these uses. For example, each time an object is about to be accessed, its reference will load its state from persistent storage or send the request to its remote location or start a transaction.</li>
</ul>
<b>COP Article:</b> <a href="http://conceptoriented.org/papers/CopInformalIntroduction.html">Informal Introduction into the Concept-Oriented Programming</a>
<b>COP forum:</b> <a href="http://conceptoriented.org/forums/index.php">http://conceptoriented.org/forums/index.php</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[But what if we assume that references, like objects, may have arbitrary domain-specific structure and behavior? Shortly, we will get a novel approach, called concept-oriented programming (COP).]]></excerpt:encoded>
		<wp:post_id>31</wp:post_id>
		<wp:post_date><![CDATA[2009-04-09 05:27:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2009-04-09 05:27:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[what-if-references-are-active-elements-of-the-program]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="active-references"><![CDATA[active references]]></category>
		<category domain="post_tag" nicename="concept-oriented-programming"><![CDATA[concept-oriented programming]]></category>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="domain-specific-references"><![CDATA[domain-specific references]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Values vs. objects in concept-oriented programming (COP)</title>
		<link>http://conceptoriented.org/blogs/?p=32</link>
		<pubDate>Tue, 12 May 2009 04:16:57 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[Values are opposed to objects because they have opposite properties, that is, values are not objects and objects are not values. For example, a value is immutable element which is passed by-copy (by-value) while objects are passed by-reference. In programming languages, values are normally stored in stack while objects are allocated in heap. Values are visible from and used by only this context while objects can be shared by many contexts. Values do not have a location in space (reference) while objects are characterized by a permanent reference.

Since OOP is about objects, values are not fully supported in this programming paradigm. In particular, the main purpose of classes in OOP consists in describing object types rather than value types. The only thing that is supported in most programming languages are primitive values with primitive types like integers. Another very important use of values supported in most OO languages is referencing. However, we are not able to create application-specific values and application-specific references -- they have a platform-specific format and behavior. (One exception is C++ where classes can be used for describing both values and objects.)

In the <a href="http://conceptoriented.org/wiki/Concept-oriented_programming">concept-oriented programming</a> (COP), both values and objects are first class citizens with the same rights. It is not simply a decorative enhancement but the recognition of the importance of values. Values in COP can account for a great deal or even most the program complexity.

For modeling values and objects COP introduces a novel programming construct, called <a href="http://conceptoriented.org/wiki/Concept_%28concept-oriented_programming%29">concept</a>. Concept is defined as a couple of two classes: one reference class <i>and</i> one object class. Reference class describes values while object class describes objects. (We call it reference class because the main role of values is a reference.) What is really new here is that these two classes cannot be used separately, that is, reference class and object class is one whole. The change of paradigm is that programming is reduced to manipulating value-object <i>couples</i>. In this context, COP informally relates to OOP as complex numbers relate to real numbers in mathematics. If in OOP elements have only one constituent -- an object, then in COP an element has always two constituents -- one value <i>and</i> one object, which are informally analogous to two constituents of complex numbers (imaginary and real part).

The next change is that <a href="http://conceptoriented.org/wiki/Inclusion_%28concept-oriented_programming%29">inclusion relation</a> is used instead of classical inheritance. In OOP terms, this means that a base element (value-object couple) may have many extensions. If values are used as references, then it is a basis for describing application-specific <a href="http://conceptoriented.org/blogs/cob/2007/06/12/modelling-hierarchical-address-space-in">hierarchical address spaces</a> like conventional postal addresses. For example, assume that concept <code>Street</code> is included in concept <code>City</code> which in turn is included in <code>Country</code>. After that each element is represented by a reference consisting of three segments: country (high), city (middle), street (low). This complex reference is a value which represents a complex object. The main different from OOP is that one country (base) can be shared among many cities (extensions) which in turn can be shared among many streets. Elements in COP are living in a hierarchical space (described by concept inclusion hierarchy) while in OOP they are living in a flat space although their classes are hierarchically ordered.

<b>COP Article:</b> <a href="http://conceptoriented.org/papers/CopInformalIntroduction.html">Informal Introduction into the Concept-Oriented Programming</a>
<b>COP forum:</b> <a href="http://conceptoriented.org/forums/index.php">http://conceptoriented.org/forums/index.php</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[Values are opposed to objects but they have different level of support in OOP. In concept-oriented programming (COP) both values and objects have equal rights because they are two sides of one element. COP uses concepts to describe its elements where a concept is a couple consisting of one reference class and one object class. Inclusion relation is used in COP instead of classical inheritance so that one base can be shared among many extensions.]]></excerpt:encoded>
		<wp:post_id>32</wp:post_id>
		<wp:post_date><![CDATA[2009-05-12 04:16:57]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2009-05-12 04:16:57]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[values-vs-objects-in-concept-oriented-programming]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="concept-oriented-programming"><![CDATA[concept-oriented programming]]></category>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="hierarchical-address-space"><![CDATA[hierarchical address space]]></category>
		<category domain="post_tag" nicename="inclusion-relation"><![CDATA[inclusion relation]]></category>
		<category domain="post_tag" nicename="objects"><![CDATA[objects]]></category>
		<category domain="post_tag" nicename="references"><![CDATA[references]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<category domain="post_tag" nicename="values"><![CDATA[values]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[Mark Lee Smith]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[netytan@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.netytan.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[150.237.85.247]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-12 17:51:44]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-12 17:51:44]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[In C# value-type objects imply structs, while reference-types imply classes. This doesn't make C# concept-oriented. Seriously, what's with the false dichotomy you're creating here?]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[savinov]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[savinov@conceptoriented.org]]></wp:comment_author_email>
			<wp:comment_author_url>http://conceptoriented.org/savinov</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[131.220.9.177]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-13 04:54:04]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-13 04:54:04]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[You are right, having value-types (structs) and reference-type is not enough for concept-orientation. To convert C# into a concept-oriented language at least the following steps need to be performed: uniting structs and classes into <i>one</i> programming construct -- <i>concept</i>, and implementing <i>concept inclusion</i> instead of inheritance. <br />
<br />
Note that COP does not belong to OOP and I described only one (of many) their distinguishing feature rather than a dichotomy of OO programming languages. In particular, it is important to understand the <i>symmetry</i> (duality) between values and objects which is absent in OOP but very important in COP.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>4</wp:comment_id>
			<wp:comment_author><![CDATA[Mark Lee Smith]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[netytan@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.netytan.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[150.237.85.248]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-13 08:11:30]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-13 08:11:30]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[savinov:<br />
<br />
OOP doesn't specify whether objects are passed by value or reference. That's an artifact of the language, rather than the object model. You're obviously quite happy to push the idea that this distinguishes OOP and COP, but there are many OO languages that support passing objects by value or by reference.<br />
<br />
It would be perfectly possible to reify references using structs in C#, in the same way that your concepts reify them in COP. Merging structs and classes into a single form would be a largely syntactic enhancement.<br />
<br />
You also use inheritance to refer strictly to single hierarchical inheritance. This is to strict. There are many many different approaches to inheritance and not all of them emply a hiearchy. Some people would consider inclusion as a form of inheritance.<br />
<br />
I'd be very interested to know what other features COP offers, because having skimmed a few of the papers linked to on this site I haven't noticed any game changers.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>5</wp:comment_id>
			<wp:comment_author><![CDATA[Mark Lee Smith]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[netytan@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.netytan.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[150.237.85.229]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-13 08:20:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-13 08:20:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[I should also add that OOP doesn't imply classes; there are classless approaches to OOP like prototype-based programming and object-based programming.<br />
<br />
You may not consider COP to be a fork of OOP, but it adds no more or less than Subject-oriented programming, Context-oriented programming or Ambient-oriented programming etc. They all change certain things about OOP; add certain features etc. But they're all OOP at heart.<br />
<br />
Maybe I'm missing something?]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>6</wp:comment_id>
			<wp:comment_author><![CDATA[savinov]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[savinov@conceptoriented.org]]></wp:comment_author_email>
			<wp:comment_author_url>http://conceptoriented.org/savinov</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[131.220.9.177]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-13 08:51:13]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-13 08:51:13]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Mark Lee Smith:<br />
<br />
<i>"OOP doesn't specify whether objects are passed by value or reference. That's an artifact of the language, rather than the object model."</i><br />
<br />
Strictly speaking you are right, but it is because OOP does not make big difference between values and objects and, as a consequence, the way they are passed is already a minor issue which can be implemented in different ways in different languages. <br />
<br />
<i>"You're obviously quite happy to push the idea that this distinguishes OOP and COP, but there are many OO languages that support passing objects by value or by reference. "</i><br />
<br />
In COP, values and objects are opposed and to say "an object is passed by-value" is non-sense. In COP, an object is defined to be passed only by-reference -- otherwise it is not an object. <br />
<br />
<i>"It would be perfectly possible to reify references using structs in C#, in the same way that your concepts reify them in COP. Merging structs and classes into a single form would be a largely syntactic enhancement."</i><br />
<br />
If we talk about values and objects then you are right -- it is not very difficult. But the main concern in COP is how objects are represented and how they are accessed, i.e., COP is about references (which are values). In this case coupling structs and classes is not a syntactic sugar because it changes how a program is viewed, how it functions and how it is written. <br />
<br />
<i>"I'd be very interested to know what other features COP offers, because having skimmed a few of the papers linked to on this site I haven't noticed any game changers."</i><br />
<br />
For example, a great deal of the program complexity is not in objects (in classes) -- some functions are concentrated in references which are active elements of the program (and modularize its cross-cutting concerns). Another example, we need an additional keyword 'sub' which is opposed to the conventional 'super'. The third change is that each concept has two methods which need to be coordinated. The third important feature is that there are two (dual) overriding strategy: base methods can override extensions and (as usual) extensions can override base methods. <br />
<br />
<i>"You also use inheritance to refer strictly to single hierarchical inheritance. This is to strict. There are many many different approaches to inheritance and not all of them emply a hiearchy. Some people would consider inclusion as a form of inheritance."</i> <br />
<br />
Inclusion turns into inheritance under certain simplifying conditions (as well as COP turns into OOP under these conditions). But the opposite is not true.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>7</wp:comment_id>
			<wp:comment_author><![CDATA[Mark Lee Smith]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[netytan@gmail.com]]></wp:comment_author_email>
			<wp:comment_author_url>http://www.netytan.com/</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[150.237.85.249]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-13 09:55:43]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-13 09:55:43]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA["Strictly speaking you are right, but it is because OOP does not make big difference between values and objects and, as a consequence, the way they are passed is already a minor issue which can be implemented in different ways in different languages."<br />
<br />
So you're moving something usually left to the language into the paradigm; that's reasonable, but you're not adding anything that wasn't there before.<br />
<br />
"In COP, values and objects are opposed and to say "an object is passed by-value" is non-sense. In COP, an object is defined to be passed only by-reference -- otherwise it is not an object."<br />
<br />
Now we're arguing about terminology ‚Äì you can define object to mean whatever you want, it doesn't change the fact that many languages allow objects to be passed by value... meaning that you can implement concepts, as you call them.<br />
<br />
And as far as I call tell, there's nothing stopping an OO language from providing inclusion in-place of standard hierarchical inheritance. (It's been a while but) I'm pretty sure Beta provided an inheritance mechanism with similar capabilities (as well as the ability to pass objects by value or reference).<br />
<br />
I'm just not seeing the big deal here. It seems like all of the things you've described fit well into existing OOP. Which is why I describe COP as a fork ‚Äì another false dichotomy. <br />]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>8</wp:comment_id>
			<wp:comment_author><![CDATA[savinov]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[savinov@conceptoriented.org]]></wp:comment_author_email>
			<wp:comment_author_url>http://conceptoriented.org/savinov</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[131.220.9.177]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2009-05-13 10:20:11]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2009-05-13 10:20:11]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA["<i>...it doesn't change the fact that many languages allow objects to be passed by value... meaning that you can implement concepts, as you call them.</i>"<br />
<br />
Unfortunately, most contemporary OO languages do [b]not[/b] suppport passing objects by-value -- and that is absolutely correct from the point of view of the OO paradigm (I would also do so if I had to implement an OO language).<br />
<br />
"<i>And as far as I call tell, there's nothing stopping an OO language from providing inclusion in-place of standard hierarchical inheritance. (It's been a while but) I'm pretty sure Beta provided an inheritance mechanism with similar capabilities (as well as the ability to pass objects by value or reference).</i>"<br />
<br />
Here is a very short comparison of inheritance vs. inclusion:<br />
<br />
Inheritance: all objects exist in one flat space; one base has one extension; all segments have one platform-specific reference (identity) provided by the compiler<br />
<br />
Inclusion: all objects exist in a hierarchy (as a tree); one base has many extensions; all segments have their own application-specific references (identities) provided by the programmer<br />
<br />
Beta provides reverse overriding strategy (where base methods override the methods of the extensions) via so called inner methods, which is a very important and underestimated feature. The same reverse overriding strategy exists in COP but is implemented differently via reference methods of concepts (one method has two definition: one in reference class and one in object class). So in Beta, objects still are normal objects living in one flat space without a hierarchy but with the addition of the mechanism of inner methods. <br />
<br />
So I do not see how inheritance (even with the Beta inner methods) can be converted to inclusion.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
		<title>Dual methods in concept-oriented programming vs. capturing and bubbling in JavaScript</title>
		<link>http://conceptoriented.org/blogs/?p=33</link>
		<pubDate>Sun, 25 Mar 2012 11:32:15 +0000</pubDate>
		<dc:creator><![CDATA[savinov]]></dc:creator>
		<guid isPermaLink="false"></guid>
		<description></description>
		<content:encoded><![CDATA[<a href="http://en.wikipedia.org/wiki/Javascript">JavaScript</a> is a prototype-based language (like <a href="http://en.wikipedia.org/wiki/Self_%28programming_language%29">Self</a>) the main use of which consists in implementing web applications by adding behavior to HTML pages. A page is represented as a tree of elements, called DOM model, where each element has one parent and many child elements. The most important distinguishing feature of prototype-based languages is that they do not use classes and parents are shared parts of children. JavaScript implements an event-based model. Events are created and processed in the context of DOM elements. For example, if a DOM element represents some kind of panel then click events will be associated with this element and then processed by a handler attached to it. 

Since DOM elements are nested the main question is in which direction events should be processed: downwards in the direction of child elements or upwards in the direction of the root element. The first (downward) event propagation strategy where parent event handlers have precedence over child handlers is referred to as <i>capturing</i>. The second (upward) event propagation strategy where child handlers have precedence over their parents is referred to as <i>bubbling</i>. For example, if we click a button within a panel then which of them will process this event first: the button (child) handler or the panel (parent) handler? These two opposite approaches were implemented in different browsers: Netscape chose the capturing (downward) model and Microsoft chose the bubbling (upward) model. The <a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/">W3C event model</a> supports both strategies so that event processing consists of two phases: first capturing down to the target element and then bubbling back up to the parent element. 

<div class="image_block"><img src="http://conceptoriented.org/blogs/wp-content/uploads/evo/dual_methods.png" alt="Dual methods in COP" title="Dual methods in COP" width="85%" /></div>

<a href="http://conceptoriented.org/wiki/Concept-oriented_programming">Concept-oriented programming</a> (COP) is similar to prototype-based languages in that objects in this model also exist in a hierarchy. The difference is that COP is a class-based approach where classes are used in a generalized form and called <a href="http://conceptoriented.org/wiki/Concept_%28concept-oriented_programming%29">concepts</a> (hence its name). Interestingly, COP has a novel method invocation model which is similar to the event propagation model in JavaScript via capturing and bubbling. This model is based on <a href="http://conceptoriented.org/wiki/Dual_methods">dual methods</a> where each method is defined two times and these two implementations are referred to as <i>incoming</i> and <i>outgoing</i> methods. Incoming methods are executed when they are called from outside (from the parent). Outgoing methods are called when they are called from inside (from the child). Such a composition means that incoming methods intercept all incoming calls while outgoing methods intercept all outgoing calls. Essentially, incoming methods implement what capturing does in JavaScript while outgoing methods implement what bubbling does. 

An advantage of dual methods is that there is only one predefined sequence of access which is controlled by two types of methods. If we do not want to intercept an event during capturing then we simply do not define the corresponding incoming method and this level will be transparent. And if we do not want to continue (capturing or bubbling) then we simply do not call the next method in the sequence. So it can be viewed as a method-based analogue of the event-based JavaScript model where instead of two-phase event processing two kinds of methods are used responsible for processing requests propagating in two opposite directions. The same mechanism in COP is used for <a href="http://www.jot.fm/issues/issue_2008_03/article2/">reverse overriding</a> and for <a href="http://conceptoriented.org/blogs/cob/2007/05/29/concept-oriented-programming-vs-aspect-o"> modeling aspects</a>. Note also that the capturing model is also analogous to inner methods in the Beta programming language. 

<b>Links:</b> 
<a href="http://javascript.info/tutorial/bubbling-and-capturing">Bubbling and capturing</a>
<a href="http://www.quirksmode.org/js/introevents.html">Introduction to Events</a>
<a href="http://www.quirksmode.org/js/events_order.html">Event order</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[JavaScript provides two directions for event propagation and processing called capturing and bubbling. Concept-oriented programing (COP) has an analogous model which is however implemented quite differently. It is based on a novel mechanism called dual methods. In this model, incoming methods process requests from the parents and outgoing methods process requests from the children.]]></excerpt:encoded>
		<wp:post_id>33</wp:post_id>
		<wp:post_date><![CDATA[2012-03-25 11:32:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2012-03-25 11:32:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[dual-methods-in-concept-oriented-programming-vs-capturing-and-bubbling-in-javascript]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bubbling"><![CDATA[bubbling]]></category>
		<category domain="post_tag" nicename="capturing"><![CDATA[capturing]]></category>
		<category domain="post_tag" nicename="concept-oriented-programming"><![CDATA[concept-oriented programming]]></category>
		<category domain="category" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="cop"><![CDATA[cop]]></category>
		<category domain="post_tag" nicename="dual-methods"><![CDATA[dual methods]]></category>
		<category domain="post_tag" nicename="event-handling"><![CDATA[event handling]]></category>
		<category domain="post_tag" nicename="incoming-methods"><![CDATA[incoming methods]]></category>
		<category domain="post_tag" nicename="javascript"><![CDATA[javascript]]></category>
		<category domain="post_tag" nicename="outgoing-methods"><![CDATA[outgoing methods]]></category>
		<category domain="post_tag" nicename="reverse-overriding"><![CDATA[reverse overriding]]></category>
		<category domain="category" nicename="main"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>9</wp:comment_id>
			<wp:comment_author><![CDATA[Peter Galiba]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[poetro@poetro.hu]]></wp:comment_author_email>
			<wp:comment_author_url>http://poetro.hu</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[91.120.172.146]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2012-04-02 20:35:35]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2012-04-02 20:35:35]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[The W3C event model has nothing to do with JavaScript. If you read the documentation, there is no word there about any particular language be it prototype or class based. It has some appendices that has examples of Java and ECMAScript bindings but the idea is language independent.<br />
<br />
So comparing this to JavaScript has no usable sense, as the event model is not part of JavaScript, it only has bindings to the native implementation.]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>10</wp:comment_id>
			<wp:comment_author><![CDATA[savinov]]></wp:comment_author>
			<wp:comment_author_email><![CDATA[savinov@conceptoriented.org]]></wp:comment_author_email>
			<wp:comment_author_url>http://conceptoriented.org/savinov</wp:comment_author_url>
			<wp:comment_author_IP><![CDATA[155.56.68.215]]></wp:comment_author_IP>
			<wp:comment_date><![CDATA[2012-04-03 11:28:49]]></wp:comment_date>
			<wp:comment_date_gmt><![CDATA[2012-04-03 11:28:49]]></wp:comment_date_gmt>
			<wp:comment_content><![CDATA[Strictly speaking you are right. But since most people use JavaScript to work with this event model, it is easier to describe its properties using this binding. The same situation is with many basic notions and models. For example, if we want to discuss inheritance then we frequently describe its properties using some popular language like Java or C++ even though they provide only one of many possible implementations. <br />]]></wp:comment_content>
			<wp:comment_approved><![CDATA[1]]></wp:comment_approved>
			<wp:comment_type><![CDATA[]]></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
</channel>
</rss>
